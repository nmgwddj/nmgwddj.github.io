<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>libwebsockets 深入应用 · Dylan's blog</title><meta name="description" content="在一些特殊网络环境下，传统的 TCP + 自定义加密协议的方式容易出现在 TCP 建连成功后首次发包没有响应的情况，这在海外连接场景非常常见，虽然数量不多但会导致阻塞性流程，导致用户无法正常使用我们提供的业务功能。
为此我们在移动端已经通过标准的 websocket 协议验证可修复这样的问题，本质的"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 8.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>libwebsockets 深入应用</a></h3></div><div class="post-content"><p>在一些特殊网络环境下，传统的 TCP + 自定义加密协议的方式容易出现在 TCP 建连成功后首次发包没有响应的情况，这在海外连接场景非常常见，虽然数量不多但会导致阻塞性流程，导致用户无法正常使用我们提供的业务功能。</p>
<p>为此我们在移动端已经通过标准的 websocket 协议验证可修复这样的问题，本质的区别是通过 TCP + 自定义加密协议鉴权的方式三次握手后的收包并不是标准的 TLS Client Hello，一些对网络安全比较苛刻的环境将直接丢弃这些数据包，导致后续的业务协议收发失败。通过 websocket 协议的方式，TCP 三次握手后第一个包是标准的 TLS 握手包，网络安全设备会正常放行。</p>
<p>本文主要介绍如何通过 libwebsockets 库实现 websocket 协议的收发。以及一些细节问题的解决方案。</p>
<span id="more"></span>

<h2 id="libwebsockets-库介绍"><a href="#libwebsockets-库介绍" class="headerlink" title="libwebsockets 库介绍"></a>libwebsockets 库介绍</h2><p>libwebsockets 是一个轻量级的 C 语言实现的 websocket 协议库，支持多种平台和操作系统，包括 Linux、Windows、macOS、Android 和 iOS 等。libwebsockets 提供了丰富的 API 接口，支持 websocket 的各种特性，如压缩、分片、二进制数据传输等。libwebsockets 的设计目标是高性能、低延迟和低内存占用，适合嵌入式设备和资源受限的环境。</p>
<h2 id="WebSocket-协议流程"><a href="#WebSocket-协议流程" class="headerlink" title="WebSocket 协议流程"></a>WebSocket 协议流程</h2><p>在一切开始前，我们先了解清楚 websocket 的整体建连发送数据的流程：</p>
<div align="center">
<img src="/images/2025/04/2025-04-27_154702.png" width=80% />
</div>

<p>抓包后看到的数据也是标准的 TLS 握手包：</p>
<div align="center">
<img src="/images/2025/04/2025-04-27_154955.png" width=80% />
</div>

<p>虽然还不确认到底网络设备是如何区分这些数据包的，但可以确定的是，websocket 协议的建连方式是可以解决这个问题的。</p>
<h2 id="libwebsockets-的使用"><a href="#libwebsockets-的使用" class="headerlink" title="libwebsockets 的使用"></a>libwebsockets 的使用</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>虽然我们是通过 conan 引入的 libwebsockets 库，但整个编译流程还是有一些细节值得介绍一下。</p>
<p>当你希望 libwebsockets 只提供客户端能力时，可通过 cmake 配置 LWS_WITHOUT_SERVER 为 0 来关闭服务器的功能，这样可以适当减少体积。另外由于业务上实现了 IPv6 和 IPv4 地址双栈竞速的逻辑，如果要开启 IPv6 支持，可通过配置 LWS_IPV6 为 1 来开启。参考命令如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cmake -DLWS_WITHOUT_SERVER=0 \</span><br><span class="line">      -DLWS_IPV6=1 \</span><br><span class="line">      -DCMAKE_BUILD_TYPE=Release \</span><br><span class="line">      ..</span><br></pre></td></tr></table></figure>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>在 libwebsockets 中，所有的操作都是通过上下文（context）来进行的。上下文是 libwebsockets 的核心数据结构，包含了所有的配置信息和状态信息。在使用 libwebsockets 之前，需要先创建一个上下文。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lws_context_creation_info</span> <span class="title">info</span>;</span></span><br><span class="line"><span class="type">fcore_link_websocket_context_t</span>* ws_context;</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;info, <span class="number">0</span>, <span class="keyword">sizeof</span>(info));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!socket-&gt;closing_) &#123;</span><br><span class="line">    fcore_link_websocket_execute_close(socket);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ws_context = fcore_link_websocket_context_create(socket);</span><br><span class="line">socket-&gt;context_ = ws_context;</span><br><span class="line"></span><br><span class="line">info.port = CONTEXT_PORT_NO_LISTEN;</span><br><span class="line">info.timeout_secs = timeout / <span class="number">1000</span>;</span><br><span class="line">info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;</span><br><span class="line">info.client_ssl_ca_filepath = fcore_global_conf_get_instance()-&gt;client_ca_file_path_;</span><br><span class="line"><span class="comment">// clang-format off</span></span><br><span class="line">info.protocols = (<span class="keyword">struct</span> lws_protocols[])&#123;&#123;</span><br><span class="line">    <span class="string">&quot;your protocol name&quot;</span>,</span><br><span class="line">    fcore_link_websocket_callback,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    <span class="number">4096</span>,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    fcx_null,</span><br><span class="line">    <span class="number">0</span></span><br><span class="line">&#125;, LWS_PROTOCOL_LIST_TERM&#125;;</span><br><span class="line"><span class="comment">// clang-format on</span></span><br><span class="line">FCX_DEBUG_APP(<span class="string">&quot;[websocket] init with client ca file path: %s&quot;</span>, info.client_ssl_ca_filepath);</span><br><span class="line"></span><br><span class="line">ws_context-&gt;lws_context = lws_create_context(&amp;info);</span><br><span class="line"><span class="keyword">if</span> (!ws_context-&gt;lws_context) &#123;</span><br><span class="line">    FCX_DEBUG_ERROR(<span class="string">&quot;Failed to create websocket context&quot;</span>);</span><br><span class="line">    fcore_link_socket_execute_onclose(socket, kFCoreConnectFailed);</span><br><span class="line">    fcx_mutex_unlock(socket-&gt;nio_thread_mutex_);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先要构造一个 <code>lws_context_creation_info</code> 结构体，并设置一些必要的参数：</p>
<ul>
<li><code>info.port = CONTEXT_PORT_NO_LISTEN;</code> 表示不监听任何端口，因为我们只需要客户端功能。</li>
<li><code>info.timeout_secs = timeout / 1000;</code> 设置超时时间。</li>
<li><code>info.options = LWS_SERVER_OPTION_DO_SSL_GLOBAL_INIT;</code> 表示初始化全局 SSL 设置，不加此设置会导致 TLS&#x2F;SSL 握手失败。</li>
<li><code>info.client_ssl_ca_filepath = fcore_global_conf_get_instance()-&gt;client_ca_file_path_;</code> 设置 CA 证书文件路径，验证服务器证书必须</li>
<li><code>info.protocols</code> 设置协议列表，这里我们只需要一个协议 nim，取决于你服务器的配置，最后的 LWS_PROTOCOL_LIST_TERM 宏表示协议列表的结束。</li>
</ul>
<p>另外一个比较重要的点是 <code>fcore_link_websocket_callback</code> 函数，它是一个回调函数，用于处理 websocket 的各种事件，如连接建立、消息接收、连接关闭等。这个函数的具体实现需要根据业务需求来编写，后面我们详细介绍。</p>
<p>随后通过 <code>lws_create_context</code> 创建一个 <code>lws_context</code> 上下文并赋值给我们业务上的上下文对象，方便在 C 风格的回调函数中使用。这样一个最简单的初始化工作就完成了。接下来是建立连接：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">lws_client_connect_info</span> <span class="title">connect_info</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;connect_info, <span class="number">0</span>, <span class="keyword">sizeof</span>(connect_info));</span><br><span class="line"></span><br><span class="line">connect_info.context = ws_context-&gt;lws_context;</span><br><span class="line">connect_info.address = host;</span><br><span class="line">connect_info.port = port;</span><br><span class="line">connect_info.path = <span class="string">&quot;/websocket&quot;</span>;</span><br><span class="line">connect_info.host = host;</span><br><span class="line">connect_info.origin = host;</span><br><span class="line">connect_info.protocol = <span class="string">&quot;your protocol name&quot;</span>;</span><br><span class="line">connect_info.userdata = ws_context;</span><br><span class="line">connect_info.ssl_connection = LCCSCF_USE_SSL;</span><br><span class="line"></span><br><span class="line">ws_context-&gt;wsi = lws_client_connect_via_info(&amp;connect_info);</span><br><span class="line"><span class="keyword">if</span> (!ws_context-&gt;wsi) &#123;</span><br><span class="line">    FCX_DEBUG_ERROR(<span class="string">&quot;Failed to connect websocket server&quot;</span>);</span><br><span class="line">    fcore_link_socket_execute_onclose(socket, kFCoreConnectFailed);</span><br><span class="line">    fcx_mutex_unlock(socket-&gt;nio_thread_mutex_);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立连接时需要依赖之前创建好的 <code>lws_context</code> 结构，通过 <code>lws_client_connect_info</code> 参数结构体来设置连接信息：</p>
<ul>
<li><code>connect_info.context = ws_context-&gt;lws_context;</code> 上下文</li>
<li><code>connect_info.address = host;</code> 服务器地址，这个地址可以是一个 IP，通过 host 来做 SNI</li>
<li><code>connect_info.port = port;</code> 服务器端口</li>
<li><code>connect_info.path = &quot;/websocket&quot;;</code> websocket 业务协议的收发路径</li>
<li><code>connect_info.host = host;</code> 主机名，主要用于 SNI</li>
<li><code>connect_info.origin = host;</code> 源地址，客户端通常不需要指定，一般用于跨域请求</li>
<li><code>connect_info.protocol = &quot;nim&quot;;</code> 协议名称，由服务器决定</li>
<li><code>connect_info.userdata = ws_context;</code> 用户数据，通常是上下文对象</li>
<li><code>connect_info.ssl_connection = LCCSCF_USE_SSL;</code> 是否使用 SSL&#x2F;TLS，如果你希望允许自签证书或跳过服务器证书校验，可添加 LCCSCF_ALLOW_SELFSIGNED 和 LCCSCF_SKIP_SERVER_CERT_HOSTNAME_CHECK 选项</li>
</ul>
<p>如果连接成功，<code>lws_client_connect_via_info</code> 函数会返回一个 <code>wsi</code> 结构，这个结构可以用于后续的消息收发和连接管理。</p>
<h3 id="启动消息循环"><a href="#启动消息循环" class="headerlink" title="启动消息循环"></a>启动消息循环</h3><p>libwebsockets 的消息循环是通过 <code>lws_service</code> 函数来实现的，该函数传入的第二个参数为 0 时表示非阻塞式。我们可以在一个单独的线程中运行这个函数，以便在后台处理 websocket 的消息。同时你可以在业务上定义一些字段表示业务流程是否已经结束，比如下面我定义了一个 <code>is_closing</code> 的字段来表示当前的 websocket 是否已经关闭：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>* FCX_STDCALL <span class="title function_">websocket_service_thread</span><span class="params">(<span class="type">void</span>* arg)</span> &#123;</span><br><span class="line">    <span class="type">fcore_link_websocket_context_t</span>* ws_context = (<span class="type">fcore_link_websocket_context_t</span>*)arg;</span><br><span class="line">    FCX_DEBUG_APP(<span class="string">&quot;[websocket] start websocket service thread&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> (!ws_context-&gt;is_closing &amp;&amp; lws_service(ws_context-&gt;lws_context, <span class="number">0</span>) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    FCX_DEBUG_APP(<span class="string">&quot;[websocket] end websocket service thread&quot;</span>)</span><br><span class="line">    ws_context-&gt;service_thread = fcx_null;</span><br><span class="line">    <span class="keyword">return</span> fcx_null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当有消息到达时，libwebsockets 会自动调用我们之前设置的回调函数 <code>fcore_link_websocket_callback</code>。这个函数的签名如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">fcore_link_websocket_callback</span><span class="params">(<span class="keyword">struct</span> lws* wsi,</span></span><br><span class="line"><span class="params">    <span class="keyword">enum</span> lws_callback_reasons reason,</span></span><br><span class="line"><span class="params">    <span class="type">void</span>* user,</span></span><br><span class="line"><span class="params">    <span class="type">void</span>* in,</span></span><br><span class="line"><span class="params">    <span class="type">size_t</span> len)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们主要需要关注的是 <code>wsi</code>、<code>reason</code> 和 <code>in</code> 三个参数：</p>
<ul>
<li><code>wsi</code>：表示当前的 websocket 连接句柄，可以通过它来获取连接的状态和信息。</li>
<li><code>reason</code>：表示当前的回调事件类型，如连接建立、消息接收、连接关闭等。</li>
<li><code>in</code>：表示接收到的数据，长度为 <code>len</code>。</li>
<li><code>user</code>：表示用户数据，这里是我们之前传入的上下文对象。</li>
</ul>
<p>在回调函数中，我们可以根据不同的事件类型来处理相应的逻辑。其中比较重要的几个事件有：</p>
<ul>
<li><p><strong>LWS_CALLBACK_CLIENT_ESTABLISHED</strong></p>
<p>表示连接建立成功，可以开始发送消息。在建立连接成功前你已经可以向发送队列投递 buffer 了，可以通过该时间回调检查 buffer 队列是否有内容以决定是否在建立连接后立即发送</p>
</li>
<li><p><strong>LWS_CALLBACK_CLIENT_CONNECTION_ERROR</strong></p>
<p>表示连接失败，可以进行错误处理，当出现该错误时可以通过 in 和 len 来获取详细的错误信息</p>
</li>
<li><p><strong>LWS_CALLBACK_CLIENT_WRITEABLE</strong></p>
<p>表示连接可写，可以发送消息。这个事件会在连接建立成功后触发，也会在发送完消息后触发，表示可以继续发送消息。当你将数据投递到发送队列后，可调用 <code>lws_callback_on_writable</code> 来通知 libwebsockets 连接可写，libwebsockets 会在下一个事件循环中调用 <code>LWS_CALLBACK_CLIENT_WRITEABLE</code> 事件。该时间回调在内部的 loop 线程中，你可以调用 <code>lws_write</code> 将缓存的 buffer 写入到发送队列中</p>
</li>
<li><p><strong>LWS_CALLBACK_CLIENT_RECEIVE</strong></p>
<p>表示接收到消息，可以处理消息。该事件会在接收到消息时触发，消息内容在 in 和 len 中</p>
</li>
</ul>
<p>另外还有关闭事件，它们在不同的场景有不同的用处：</p>
<ul>
<li><p><strong>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</strong></p>
<p>表示对端主动关闭连接，可以进行清理工作。该事件会在对端主动关闭连接时触发，客户端可判断连接到底是端上主动关闭还是由对端关闭</p>
</li>
<li><p><strong>LWS_CALLBACK_CLIENT_CLOSED</strong></p>
<p>表示当前客户端连接已经关闭，可以进行清理工作。即使触发了 <code>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</code> 也同样会触发该事件</p>
</li>
</ul>
<p>所以区分连接是有对端关闭还是本端关闭的，主要是通过 <code>LWS_CALLBACK_WS_PEER_INITIATED_CLOSE</code> 事件来判断的。</p>
<h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p>libwebsockets 提供了两个版本的 API，一组是 low level API，另一组是 high level API。low level API 提供了更底层的控制，可以直接操作数据包的格式和内容，而 high level API 则提供了更简单易用的接口，适合大多数应用场景。由于需要更精细化的控制收发数据，我们选择了 low level API。从官方的示例代码中也区分了这两种 API 的使用方式，其中 low level API 发送数据指的就是上面提到的 lws_write 方法来将数据写入到发送队列中。但 low level API 要特殊处理一些功能，在介绍前我们先搞清楚 lws_write 的工作模式。</p>
<p>发送 websocket 数据时，业务上实现实际需要预留一部分空间来填充数据包头部信息，libwebsockets 会根据你发送的数据自动将头部信息填充到 buffer 中。我们需要在发送数据时给 buffer 预留出 <code>LWS_PRE</code>（libwebsockets 头文件中定义，大小为 4+10+2）字节的空间来存放数据包头部信息。所以你不能将你业务数据的 buffer 直接丢给 lws_write 方法。这样会导致严重的内存越界问题。实际内存分配的情况参考下图：</p>
<div align="center">
<img src="/images/2025/04/2025-04-27_165727.png" width=80% />
</div>

<p>在调用发送数据前，我们先申请一个 buffer，大小为 <code>LWS_PRE + data_len</code>，然后将数据填充到 buffer 中。最后调用 <code>lws_write</code> 发送数据。伪代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> data_len = <span class="built_in">strlen</span>(data);</span><br><span class="line"><span class="type">size_t</span> buffer_len = LWS_PRE + data_len;</span><br><span class="line"><span class="type">char</span>* buffer = (<span class="type">char</span>*)<span class="built_in">malloc</span>(buffer_len);</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="number">0</span>, buffer_len);</span><br><span class="line"><span class="built_in">memcpy</span>(buffer + LWS_PRE, data, data_len);</span><br><span class="line"><span class="type">int</span> n = lws_write(ws_context-&gt;wsi, (<span class="type">unsigned</span> <span class="type">char</span>*)buffer + LWS_PRE, data_len, LWS_WRITE_BINARY);</span><br><span class="line"><span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">    <span class="built_in">free</span>(buffer);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样其实已经能简单的实现发送数据逻辑了，但如果你希望控制写入到发送队列的 buffer 大小，可以分批次将数据写入到发送队列中，控制 lws_write 第三个参数的 write mode 来告诉 libwebsockets 数据是不是写入完成了。以下是业务上正在使用代码的片段，可作为参考：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历队列中的所有item</span></span><br><span class="line"><span class="type">fcx_list_item_t</span>* current_item = context-&gt;tx_queue-&gt;head;</span><br><span class="line"><span class="keyword">while</span> (current_item &amp;&amp; !lws_send_pipe_choked(wsi)) &#123;</span><br><span class="line">    <span class="type">fcx_buffer_t</span>* buffer = (<span class="type">fcx_buffer_t</span>*)current_item-&gt;data;</span><br><span class="line">    <span class="keyword">if</span> (!buffer) &#123;</span><br><span class="line">        current_item = current_item-&gt;next;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> bytes_sent = <span class="number">0</span>;</span><br><span class="line">    <span class="type">fcx_bool_t</span> buffer_sent = fcx_false;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!lws_send_pipe_choked(wsi) &amp;&amp; !FCX_BUFFER_IS_EMPTY(buffer)) &#123;</span><br><span class="line">        <span class="type">size_t</span> total_size = FCX_BUFFER_SIZE(buffer) - LWS_PRE;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span>* buffer_start = (<span class="type">unsigned</span> <span class="type">char</span>*)FCX_BUFFER_DATA(buffer) + LWS_PRE + bytes_sent;</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent &gt;= total_size) &#123;</span><br><span class="line">            buffer_sent = fcx_true;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">size_t</span> remaining_size = total_size - bytes_sent;</span><br><span class="line">        <span class="type">size_t</span> frame_size =</span><br><span class="line">            remaining_size &gt; WEBSOCKET_WRITE_BUFFER_LENGTH ? WEBSOCKET_WRITE_BUFFER_LENGTH : remaining_size;</span><br><span class="line">        <span class="type">int</span> write_mode = bytes_sent == <span class="number">0</span> ? LWS_WRITE_BINARY : LWS_WRITE_CONTINUATION;</span><br><span class="line">        <span class="keyword">if</span> (frame_size &lt; remaining_size) &#123;</span><br><span class="line">            write_mode |= LWS_WRITE_NO_FIN;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> written = lws_write(wsi, buffer_start, frame_size, write_mode);</span><br><span class="line">        <span class="keyword">if</span> (written &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            FCX_DEBUG_ERROR(<span class="string">&quot;Failed to write to socket, frame size: %zu, written size: %d&quot;</span>, frame_size, written);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bytes_sent += written;</span><br><span class="line">        <span class="keyword">if</span> (bytes_sent &gt;= total_size) &#123;</span><br><span class="line">            buffer_sent = fcx_true;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 单个包超过了 WEBSOCKET_WRITE_BUFFER_LENGTH，将已经发送的数据移除，待下次发送</span></span><br><span class="line">        fcx_buffer_remove(buffer, LWS_PRE, written);</span><br><span class="line">        <span class="keyword">if</span> (lws_partial_buffered(wsi))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">fcx_list_item_t</span>* next_item = current_item-&gt;next;</span><br><span class="line">    <span class="comment">// 如果 buffer 已经完全发送，从队列中移除，并将指针指向下一个待发送 buffer</span></span><br><span class="line">    <span class="keyword">if</span> (buffer_sent) &#123;</span><br><span class="line">        fcx_buffer_cleanup(buffer);</span><br><span class="line">        fcx_list_remove_item(context-&gt;tx_queue, current_item);</span><br><span class="line">        current_item = next_item;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 write mode 的 <code>LWS_WRITE_CONTINUATION</code> | <code>LWS_WRITE_NO_FIN</code> 表示当前业务数据 buffer 是否已经写入完成。这个可跟业务实际情况调整。</p>
<h3 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h3><p>接收数据时，libwebsockets 会自动将接收到的数据存储在 <code>in</code> 指针指向的内存中，长度为 <code>len</code>。不像发送数据，接收数据时不需要预留空间。我们只需要在回调函数中处理接收到的数据即可。以下是一个简单的接收数据的示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> LWS_CALLBACK_CLIENT_RECEIVE: &#123;</span><br><span class="line">    <span class="keyword">if</span> (!in || len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 扩展接收缓冲区</span></span><br><span class="line">    <span class="type">size_t</span> new_size = context-&gt;rx_buffer_size + len;</span><br><span class="line">    <span class="type">char</span>* new_buffer = (<span class="type">char</span>*)<span class="built_in">realloc</span>(context-&gt;rx_buffer, new_size);</span><br><span class="line">    <span class="keyword">if</span> (!new_buffer) &#123;</span><br><span class="line">        FCX_DEBUG_ERROR(<span class="string">&quot;Failed to allocate receive buffer&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    context-&gt;rx_buffer = new_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制新数据到缓冲区</span></span><br><span class="line">    <span class="built_in">memcpy</span>(context-&gt;rx_buffer + context-&gt;rx_buffer_pos, in, len);</span><br><span class="line">    context-&gt;rx_buffer_size = new_size;</span><br><span class="line">    context-&gt;rx_buffer_pos += len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查是否是最后一个分片且没有剩余数据</span></span><br><span class="line">    <span class="keyword">if</span> (lws_is_final_fragment(wsi) &amp;&amp; lws_remaining_packet_payload(wsi) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 发送完整的消息</span></span><br><span class="line">        fcore_link_socket_post_receive_task(</span><br><span class="line">            context-&gt;socket, kFCoreNetOk, context-&gt;rx_buffer, context-&gt;rx_buffer_size);</span><br><span class="line">        <span class="comment">// 重置缓冲区</span></span><br><span class="line">        <span class="built_in">free</span>(context-&gt;rx_buffer);</span><br><span class="line">        context-&gt;rx_buffer = <span class="literal">NULL</span>;</span><br><span class="line">        context-&gt;rx_buffer_size = <span class="number">0</span>;</span><br><span class="line">        context-&gt;rx_buffer_pos = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>至此，libwebsockets 的初始化、建连、消息循环、发送和接收数据的基本流程已经介绍完毕，这是最近一段时间在对接该库时总结下来的一些经验和教训，希望能对预期使用 libwebsockets 的同学们有所帮助。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2025-04-27</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2025/04/27/2025/2025-04-27-152300/,Dylan's blog,libwebsockets 深入应用,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2025/05/20/2025/2025-05-20-194316/" title="SSL/TLS 安全传输 Root CA 管理之痛">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/12/21/2023/2023-12-21-112758/" title="合理的设置 libcurl 几种超时参数">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>