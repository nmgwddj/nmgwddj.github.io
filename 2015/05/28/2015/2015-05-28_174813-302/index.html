<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>线性表链式存储 | Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>线性表链式存储</h1>
    </header>

    <section>
      <p>上文中我们介绍了线性表顺序储存的方式，并给大家画了一幅比较详细的图（虽然看着比较凌乱），本文介绍的是数据储存的另外一种方式“链式储存”，这相当于我们之前提到过的<a target="_blank" rel="noopener" href="http://www.mycode.net.cn/datastruct/21.html">单向链表</a>，但是，本文与上一篇文章一样，都将数据的储存和算法进行了分离。这才是我们真正应该晋级了解的东西，如果只是一个单向链表，不足以我们耗费这么多精力。</p>
<span id="more"></span>
<h3 id="【表示图】"><a href="#【表示图】" class="headerlink" title="【表示图】"></a>【表示图】</h3><p>下图是我们使用链式储存数据的方式表示图，其中用户层生成了栈上的数据，然后将栈上的数据使用强制类型转换转换成了实现层可以识别的数据，转换过程中，出现了数据截断，但这并不重要，重要的是截断后得到了一个 LinkListNode* 类型的指针，我们利用这些指针，将数据在实现内部串联成一个多个指向某地址的指针组成的链表，这些指针就指向了外部传递进来的数据的头部位置。这样就实现了，外部调用层管理数据的生命周期，而在实现层管理数据的储存和链接，中间通过一个 LinkListNode* 结构体巧妙的将数据转换为调用层和实现层都可识别的数据。 <a href="/images/2015/05/2015-05-28_174630.png"><img src="/images/2015/05/2015-05-28_174630.png" alt="2015-05-28_174630"></a></p>
<h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><p>#ifndef _LINK_LIST_H<br>#define _LINK_LIST_H</p>
<p>typedef void LinkList;<br>typedef struct _tag_LinkList_Node<br>{<br>struct _tag_LinkList_Node* next;<br>}LinkListNode;</p>
<p>&#x2F;&#x2F;创建链式线性表<br>LinkList* LinkList_Create();</p>
<p>&#x2F;&#x2F;销毁链式线性表<br>void LinkList_Destroy(LinkList* list);</p>
<p>&#x2F;&#x2F;清空链式线性表<br>void LinkList_Clear(LinkList* list);</p>
<p>&#x2F;&#x2F;获取链式线性表长度<br>int LinkList_Length(LinkList* list);</p>
<p>&#x2F;&#x2F;往链式线性表中插入节点<br>int LinkList_Insert(LinkList* list, LinkListNode* node, int pos);</p>
<p>&#x2F;&#x2F;获取链式线性表中某个位置的元素<br>LinkListNode* LinkList_Get(LinkList* list, int pos);</p>
<p>&#x2F;&#x2F;删除链式线性表中某个位置的元素<br>LinkListNode* LinkList_Delete(LinkList* list, int pos);</p>
<p>#endif &#x2F;&#x2F;_LINK_LIST_H</p>
<p>#include “LinkList.h”<br>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;</p>
<p>typedef struct tag_LinkList<br>{<br>int length;<br>LinkListNode header;<br>}TLinkList;</p>
<p>LinkList* LinkList_Create()<br>{<br>TLinkList* tlist &#x3D; (TLinkList*)malloc(sizeof(TLinkList));</p>
<p>tlist-&gt;length &#x3D; 0;<br>tlist-&gt;header.next &#x3D; NULL;</p>
<p>return tlist;<br>}</p>
<p>void LinkList_Destroy(LinkList* list)<br>{<br>if (NULL &#x3D;&#x3D; list) return;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;</p>
<p>free(tlist);<br>}</p>
<p>void LinkList_Clear(LinkList* list)<br>{<br>if (NULL &#x3D;&#x3D; list) return;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;</p>
<p>tlist-&gt;length &#x3D; 0;<br>tlist-&gt;header.next &#x3D; NULL;<br>}</p>
<p>int LinkList_Length(LinkList* list)<br>{<br>if (NULL &#x3D;&#x3D; list) return -1;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;</p>
<p>return tlist-&gt;length;<br>}</p>
<p>int LinkList_Insert(LinkList* list, LinkListNode* node, int pos)<br>{<br>if (NULL &#x3D;&#x3D; list) return -1;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;<br>&#x2F;&#x2F; 备份指针，指向 tlist 表的头节点<br>LinkListNode* pCur &#x3D; &amp;tlist-&gt;header;</p>
<p>for (int i &#x3D; 0; i &lt; pos; i++)<br>{<br>&#x2F;&#x2F; 备份指针后移到 pos 的位置的前一个节点<br>pCur &#x3D; pCur-&gt;next;<br>}</p>
<p>&#x2F;&#x2F; 让新来的节点先有所指向<br>node-&gt;next &#x3D; pCur-&gt;next;<br>pCur-&gt;next &#x3D; node;</p>
<p>&#x2F;&#x2F; 记录链表有效节点个数的变量++<br>tlist-&gt;length++;</p>
<p>return 0;<br>}</p>
<p>LinkListNode* LinkList_Get(LinkList* list, int pos)<br>{<br>if (NULL &#x3D;&#x3D; list) return NULL;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;<br>&#x2F;&#x2F; 备份指针，指向 tlist 表的头节点<br>LinkListNode* pCur &#x3D; &amp;tlist-&gt;header;</p>
<p>for (int i &#x3D; 0; i &lt; pos; i++)<br>{<br>&#x2F;&#x2F; 备份指针后移到 pos 的位置的前一个节点<br>pCur &#x3D; pCur-&gt;next;<br>}</p>
<p>return pCur-&gt;next;<br>}</p>
<p>LinkListNode* LinkList_Delete(LinkList* list, int pos)<br>{<br>if (NULL &#x3D;&#x3D; list) return NULL;<br>&#x2F;&#x2F; 将类型转换为内部可识别的类型<br>TLinkList* tlist &#x3D; (TLinkList*)list;<br>&#x2F;&#x2F; 备份指针，指向 tlist 表的头节点<br>LinkListNode* pCur &#x3D; &amp;tlist-&gt;header;</p>
<p>for (int i &#x3D; 0; i &lt; pos; i++)<br>{<br>&#x2F;&#x2F; 备份指针后移到 pos 的位置的前一个节点<br>pCur &#x3D; pCur-&gt;next;<br>}</p>
<p>LinkListNode* pDel &#x3D; pCur-&gt;next;<br>pCur-&gt;next &#x3D; pDel-&gt;next;</p>
<p>tlist-&gt;length–;</p>
<p>return pDel;<br>}</p>
<p>#include “LinkList.h”<br>#include &lt;stdio.h&gt;</p>
<p>&#x2F;&#x2F; 外部要储存的数据结构<br>typedef struct tag_Teacher<br>{<br>LinkListNode node;<br>int age;<br>char name[24];<br>}Teacher;</p>
<p>int main()<br>{<br>&#x2F;&#x2F; 创建一个链表<br>LinkList* list &#x3D; LinkList_Create();<br>if (NULL &#x3D;&#x3D; list) return -1;</p>
<p>Teacher tea[10];<br>for (int i &#x3D; 0; i &lt; 10; i++)<br>{<br>tea[i].age &#x3D; i + 20;<br>sprintf_s(tea[i].name, “teacher_%d”, i);<br>printf(“address &#x3D; %p\n”, (LinkListNode*)&amp;tea[i]);<br>LinkList_Insert(list, (LinkListNode*)&amp;tea[i], i);<br>}</p>
<p>for (int i &#x3D; 0; i &lt; LinkList_Length(list); i++)<br>{<br>Teacher *pTea &#x3D; (Teacher*)LinkList_Get(list, i);<br>printf(“address &#x3D; %p, Teacher age &#x3D; %d, name &#x3D; %s\n”, pTea, pTea-&gt;age, pTea-&gt;name);<br>}</p>
<p>while (LinkList_Length(list))<br>{<br>Teacher *pTea &#x3D; (Teacher*)LinkList_Delete(list, 0);<br>printf(“delete – Teacher age &#x3D; %d, name &#x3D; %s\n”, pTea-&gt;age, pTea-&gt;name);<br>}</p>
<p>LinkList_Destroy(list);</p>
<p>return 0;<br>}</p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2015-05-28T17:48:13.000Z" itemprop="datePublished">
              2015-05-28
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/%E6%8C%87%E9%92%88/">指针</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%9F%A5%E6%89%BE/">查找</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E8%BF%9B%E7%A8%8B%E7%A9%BA%E9%97%B4/">进程空间</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">类型转换</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>