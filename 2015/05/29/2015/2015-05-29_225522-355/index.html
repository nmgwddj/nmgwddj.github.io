<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>栈应用代码检测就近匹配 · Dylan's blog</title><meta name="description" content="你在使用编辑器写代码的时候是否思考过这个问题：如果少写了一个大括号或中括号，编辑器就会提示错误，这种做法是怎么做到的呢？ 其实这个检测就可以通过栈模型来实现，括号的数量总是匹配出现的，并且都是与最近的一个匹配。我们可以编写代码来实现这个检测的功能。具体实现思路如下：
从第一个字符开始扫描, 当遇见普"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>栈应用代码检测就近匹配</a></h3></div><div class="post-content"><p>你在使用编辑器写代码的时候是否思考过这个问题：如果少写了一个大括号或中括号，编辑器就会提示错误，这种做法是怎么做到的呢？ 其实这个检测就可以通过栈模型来实现，括号的数量总是匹配出现的，并且都是与最近的一个匹配。我们可以编写代码来实现这个检测的功能。具体实现思路如下：</p>
<p>从第一个字符开始扫描, 当遇见普通字符时忽略，<br>当遇见左符号时压入栈中<br>当遇见右符号时从栈中弹出栈顶符号，并进行匹配.<br>匹配成功：继续读入下一个字符<br>匹配失败：立即停止，并报错<br>结束.<br>——成功: 所有字符扫描完毕，且栈为空<br>——失败：匹配失败或所有字符扫描完毕但栈非空</p>
<p>【实现代码】 以下代码需要用到<a target="_blank" rel="noopener" href="http://www.mycode.net.cn/datastruct/334.html">栈模型链式存储的 LinkStack.h 和 LinkStack.c 头文件</a>：</p>
<p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;<br>#include &lt;string.h&gt;<br>#include “LinkStack.h”</p>
<p>&#x2F;***************** 算法思路 *****************<br>从第一个字符开始扫描, 当遇见普通字符时忽略，<br>当遇见左符号时压入栈中<br>当遇见右符号时从栈中弹出栈顶符号，并进行匹配.<br>匹配成功：继续读入下一个字符<br>匹配失败：立即停止，并报错<br>结束.<br>——成功: 所有字符扫描完毕，且栈为空<br>——失败：匹配失败或所有字符扫描完毕但栈非空*&#x2F;</p>
<p>int match(char left, char right)<br>{<br>int ret &#x3D; 0;<br>switch (left)<br>{<br>case ‘&lt;’:&#x2F;&#x2F;左尖括号<br>ret &#x3D; (right &#x3D;&#x3D; ‘&gt;’);<br>break;<br>case ‘(‘:&#x2F;&#x2F;左小括号<br>ret &#x3D; (right &#x3D;&#x3D; ‘)’);<br>break;<br>case ‘[‘:&#x2F;&#x2F;左中括号<br>ret &#x3D; (right &#x3D;&#x3D; ‘]‘);<br>break;<br>case ‘{‘:&#x2F;&#x2F;左大括号<br>ret &#x3D; (right &#x3D;&#x3D; ‘}’);<br>break;<br>case ‘\‘’:&#x2F;&#x2F;左单引号<br>ret &#x3D; (right &#x3D;&#x3D; ‘\‘’);<br>break;<br>case ‘\“‘:&#x2F;&#x2F;左双引号<br>ret &#x3D; (right &#x3D;&#x3D; ‘\“‘);<br>break;<br>default:<br>ret &#x3D; 0;<br>break;<br>}</p>
<p>&#x2F;&#x2F;匹配成功返回1,不成功返回0<br>return ret;<br>}</p>
<p>int isRight(char right)<br>{<br>int ret &#x3D; 0;<br>switch (right)<br>{<br>case ‘&gt;’:&#x2F;&#x2F;右尖括号<br>case ‘)’:&#x2F;&#x2F;右小括号<br>case ‘]‘:&#x2F;&#x2F;右中括号<br>case ‘}’:&#x2F;&#x2F;右大括号<br>case ‘\‘’:&#x2F;&#x2F;右单引号<br>case ‘\“‘:&#x2F;&#x2F;右双引号<br>ret &#x3D; 1;&#x2F;&#x2F;是需要检测的符号返回1<br>break;<br>default:<br>ret &#x3D; 0;&#x2F;&#x2F;不是需要检测的符号返回0<br>break;<br>}<br>return ret;<br>}</p>
<p>int isLeft(char left)<br>{<br>int ret &#x3D; 0;<br>switch (left)<br>{<br>case ‘&lt;’:&#x2F;&#x2F;左尖括号<br>case ‘(‘:&#x2F;&#x2F;左小括号<br>case ‘[‘:&#x2F;&#x2F;左中括号<br>case ‘{‘:&#x2F;&#x2F;左大括号<br>case ‘\‘’:&#x2F;&#x2F;左单引号<br>case ‘\“‘:&#x2F;&#x2F;左双引号<br>ret &#x3D; 1;&#x2F;&#x2F;是需要检测的符号返回1<br>break;<br>default:<br>ret &#x3D; 0;&#x2F;&#x2F;不是需要检测的符号返回0<br>break;<br>}<br>return ret;<br>}</p>
<p>int read(const char* code)<br>{<br>int i &#x3D; 0;<br>LinkStack* stack &#x3D; LinkStack_Create();</p>
<p>while (code[i])<br>{<br>&#x2F;&#x2F; 判断是否是左符号<br>if (isLeft(code[i]))<br>{<br>&#x2F;&#x2F; 是的话就压如栈中<br>printf(“push &#x3D; %c\n”, code[i]);<br>LinkStack_Push(stack, (void*)&amp;code[i]);<br>&#x2F;&#x2F;continue;<br>}</p>
<p>&#x2F;&#x2F; 判断是否是右符号<br>if (isRight(code[i]))<br>{<br>&#x2F;&#x2F; 如果是则取出栈顶的符号与这个右符号对比<br>char left &#x3D; *(char*)LinkStack_Top(stack);<br>if (match(left, code[i]))<br>{<br>&#x2F;&#x2F; 匹配成功，从栈中弹出匹配过的左符号<br>printf(“pop  &#x3D; %c\n”, code[i]);<br>LinkStack_Pop(stack);<br>}<br>else<br>{<br>&#x2F;&#x2F; 匹配失败直接报错并终止循环<br>printf(“数据异常，匹配失败！ left &#x3D; %c, right &#x3D; %c\n”, left, code[i]);<br>break;<br>}<br>}<br>i++;<br>}</p>
<p>&#x2F;&#x2F; 最后判断栈中是否还有数据，如果还有证明缺少右符号<br>if (!LinkStack_Size(stack))<br>{<br>printf(“匹配成功！\n”);<br>}<br>else<br>{<br>char ch &#x3D; *(char*)LinkStack_Top(stack);<br>printf(“缺少匹配 %c\n”, ch);<br>}<br>&#x2F;&#x2F; 销毁<br>LinkStack_Destroy(stack);<br>return 0;<br>}</p>
<p>int main(int argc, char* argv[])<br>{<br>const char* code &#x3D; “#include &lt;stdio.h&gt; int main() { int a[4][4]; int (*p)[4]; p &#x3D; a[0]; return 0;}”;<br>read(code);</p>
<p>return 0;<br>}</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-29</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/categories/DataStruct/" title="DataStruct">DataStruct </a><a class="tag" href="/tags/链表/" title="链表">链表 </a><a class="tag" href="/tags/字符串/" title="字符串">字符串 </a><a class="tag" href="/tags/指针/" title="指针">指针 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2015/05/29/2015/2015-05-29_225522-355/,Dylan's blog,栈应用代码检测就近匹配,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/05/31/2015/2015-05-31_162717-357/" title="栈的应用中缀转后缀表达式">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/05/28/2015/2015-05-28_223504-334/" title="Stack 栈模型的链式存储实现">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>