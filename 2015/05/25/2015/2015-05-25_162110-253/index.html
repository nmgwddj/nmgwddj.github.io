<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>cocos2dx 入口分析 | Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>cocos2dx 入口分析</h1>
    </header>

    <section>
      <p>为了理解多态的进一步应用，老师带着我们简单分析了一下cocos2dx的入口，深刻的体会到了虚函数和类静态成员变量的作用。以此给大家分享一下这个过程。</p>
<span id="more"></span>
<p>打开cocos2dx的main.cpp文件，我们可以看到如下代码： <a href="/images/2015/05/2015-05-17_191143.png"><img src="/images/2015/05/2015-05-17_191143.png" alt="2015-05-17_191143"></a></p>
<p>#include “main.h”<br>#include “AppDelegate.h”<br>#include “CCEGLView.h”<br> <br>USING_NS_CC;<br> <br>int APIENTRY _tWinMain(HINSTANCE hInstance,<br>                       HINSTANCE hPrevInstance,<br>                       LPTSTR    lpCmdLine,<br>                       int       nCmdShow)<br>{<br>    UNREFERENCED_PARAMETER(hPrevInstance);<br>    UNREFERENCED_PARAMETER(lpCmdLine);<br> <br>    &#x2F;&#x2F; create the application instance<br>    AppDelegate app;<br>    CCEGLView* eglView &#x3D; CCEGLView::sharedOpenGLView();<br>    eglView-&gt;setViewName(“cocos2dx”);<br>    eglView-&gt;setFrameSize(480, 320);<br>    return CCApplication::sharedApplication()-&gt;run();</p>
<p>}</p>
<p>其中，AppDelegate 上方有一段注释，提示创建应用程序实例。随后加载了 OpenGL 的库，最后一句 return 返回了 CCApplication 的一个成员函数的返回值，其中最重要的两句就是创建了 AppDelegate app 对象以及最后一句 return 所调用的 run() 函数，他们中间利用多态的概念成功的开辟了一个程序的入口点。 下面我们先分析一下 AppDelegate 类的结构。 <a href="/images/2015/05/2015-05-17_191943.png"><img src="/images/2015/05/2015-05-17_191943.png" alt="2015-05-17_191943"></a> AppDelegate 类继承了 CCApplication 类，而且我们可以看到，继承的权限是 private 的。也就是说，他没有继承任何父类的资源，但是其内部实现了几个方法，这几个方法全部是继承下来的虚函数，并且在 AppDelegate  类中均做了实现：</p>
<p>virtual bool applicationDidFinishLaunching();<br>virtual void applicationDidEnterBackground();<br>virtual void applicationWillEnterForeground();</p>
<p>其中最重要的一个就是 applicationDidFinishLaunching() 方法，后面你将看到他的面目。 因 AppDelegate的父类是 CCApplication 类，所以在实例化一个 AppDelegate 对象时会调用 CCApplication 类的构造器，那么接下来我们看一下CCApplication 类的构造器。</p>
<dl><dt>CCApplication::CCApplication()</dt><dd>m_hInstance(NULL)<br>, m_hAccelTable(NULL)<br>{<br>    m_hInstance    &#x3D; GetModuleHandle(NULL);<br>    m_nAnimationInterval.QuadPart &#x3D; 0;<br>    CC_ASSERT(! sm_pSharedApplication);<br>    sm_pSharedApplication &#x3D; this;<br>}</dd></dl><p>构造器最后一句便是将一个将 sm_pSharedApplication 变量设置为 this;也就是说，当这个类有对象实例化时，则把这个对象的指针付给 sm_pSharedApplication 变量，但是此时你会发现，CCApplication 类是从CCApplicationProtocol 类中继承下来的，CCApplicationProtocol 类是一个抽象类，包含有多个纯虚函数，在CCApplication 类内部并没有对这些纯虚函数进行实现，所以当前 CCApplication 类也是一个抽象类，无法被实例化的。这里把 this 赋值给 sm_pSharedApplication 有什么意义吗？ 在考虑这个问题之前，回想一下之前实例化的 AppDelegate的对象，该类构建时会调用父类 CCApplication 类的构造器，换个角度说，CCApplication 类无法实例化对象，但其子类是可以实例化对象的，并且其子类继承了CCApplication 类所有没有实现的纯虚函数并做了实现。在实例化对象时，这个 this 就指向了我们在main函数中看到的 app 对象。过程如下图： <a href="/images/2015/05/2015-05-17_200151.png"><img src="/images/2015/05/2015-05-17_200151.png" alt="2015-05-17_200151"></a> 此时 this 指向实例化的对象 app ，在 CCApplication 类的构造器中，将该指针赋值给了 sm_pSharedApplication 。在 CCApplication 类的成员中，我们找到了 sm_pSharedApplication 成员，他被声明为一个 static 变量，也就是在整个应用程序中，它都是有效的，得到这个结论后，我们知道了以下信息。 1、 AppDelegate 类继承了CCApplication 类并实现了所有从 CCApplicationProtocol 类中继承下来的纯虚函数。 2、当实例化一个 AppDelegate 类的对象时，调用了 CCApplication 类的构造器，将 AppDelegate 对象的指针赋值给了一个 CCApplication 类的静态的成员变量 sm_pSharedApplication。 接下来，我们再来分析最后一步：</p>
<p>return CCApplication::sharedApplication()-&gt;run();</p>
<p>首先调用了 CCApplication 类的成员方法 sharedApplication()，该方法实现如下：</p>
<p>CCApplication* CCApplication::sharedApplication()<br>{<br>    CC_ASSERT(sm_pSharedApplication);<br>    return sm_pSharedApplication;<br>}</p>
<p>它只是获取了一下静态变量 sm_pSharedApplication 的值并返回。返回后再次调用了 CCApplication 类的方法 run()，在 run() 中，调用了由 AppDelegate 类实现的方法 applicationDidFinishLaunching()：</p>
<p>&#x2F;&#x2F; Initialize instance and cocos2d.<br>if (!applicationDidFinishLaunching())<br>{<br>    return 0;<br>}</p>
<p>回想一下多态实现的三个条件。 1，是父类中有虚函数。（CCApplicationProtocol 类中多个纯虚函数） 2，子类 override(覆写)父类中的虚函数（AppDelegate 类覆写了所有纯虚函数） 3，通过己被子类对象赋值的父类指针，调用共用接口（利用静态变量 sm_pSharedApplication 做中介将AppDelegate 实例化的对象指针通过 this 的方式存放到 sm_pSharedApplication 中，最后借用成员函数 run() 调用了共用接口 applicationDidFinishLaunching()） 以上便是coco2dx利用多态的特性构建的一个程序入口。不得不感叹真的是把C++玩飞了。</p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2015-05-25T16:21:10.000Z" itemprop="datePublished">
              2015-05-25
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/%E7%B1%BB/">类</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E5%A4%9A%E6%80%81/">多态</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%B4%BE%E7%94%9F/">继承与派生</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>