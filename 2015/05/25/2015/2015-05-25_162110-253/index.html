<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>cocos2dx 入口分析 · Dylan's blog</title><meta name="description" content="为了理解多态的进一步应用，老师带着我们简单分析了一下cocos2dx的入口，深刻的体会到了虚函数和类静态成员变量的作用。以此给大家分享一下这个过程。

打开cocos2dx的main.cpp文件，我们可以看到如下代码： 
#include “main.h”#include “AppDelegate."><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>cocos2dx 入口分析</a></h3></div><div class="post-content"><p>为了理解多态的进一步应用，老师带着我们简单分析了一下cocos2dx的入口，深刻的体会到了虚函数和类静态成员变量的作用。以此给大家分享一下这个过程。</p>
<span id="more"></span>
<p>打开cocos2dx的main.cpp文件，我们可以看到如下代码： <a href="/images/2015/05/2015-05-17_191143.png"><img src="/images/2015/05/2015-05-17_191143.png" alt="2015-05-17_191143"></a></p>
<p>#include “main.h”<br>#include “AppDelegate.h”<br>#include “CCEGLView.h”<br> <br>USING_NS_CC;<br> <br>int APIENTRY _tWinMain(HINSTANCE hInstance,<br>                       HINSTANCE hPrevInstance,<br>                       LPTSTR    lpCmdLine,<br>                       int       nCmdShow)<br>{<br>    UNREFERENCED_PARAMETER(hPrevInstance);<br>    UNREFERENCED_PARAMETER(lpCmdLine);<br> <br>    &#x2F;&#x2F; create the application instance<br>    AppDelegate app;<br>    CCEGLView* eglView &#x3D; CCEGLView::sharedOpenGLView();<br>    eglView-&gt;setViewName(“cocos2dx”);<br>    eglView-&gt;setFrameSize(480, 320);<br>    return CCApplication::sharedApplication()-&gt;run();</p>
<p>}</p>
<p>其中，AppDelegate 上方有一段注释，提示创建应用程序实例。随后加载了 OpenGL 的库，最后一句 return 返回了 CCApplication 的一个成员函数的返回值，其中最重要的两句就是创建了 AppDelegate app 对象以及最后一句 return 所调用的 run() 函数，他们中间利用多态的概念成功的开辟了一个程序的入口点。 下面我们先分析一下 AppDelegate 类的结构。 <a href="/images/2015/05/2015-05-17_191943.png"><img src="/images/2015/05/2015-05-17_191943.png" alt="2015-05-17_191943"></a> AppDelegate 类继承了 CCApplication 类，而且我们可以看到，继承的权限是 private 的。也就是说，他没有继承任何父类的资源，但是其内部实现了几个方法，这几个方法全部是继承下来的虚函数，并且在 AppDelegate  类中均做了实现：</p>
<p>virtual bool applicationDidFinishLaunching();<br>virtual void applicationDidEnterBackground();<br>virtual void applicationWillEnterForeground();</p>
<p>其中最重要的一个就是 applicationDidFinishLaunching() 方法，后面你将看到他的面目。 因 AppDelegate的父类是 CCApplication 类，所以在实例化一个 AppDelegate 对象时会调用 CCApplication 类的构造器，那么接下来我们看一下CCApplication 类的构造器。</p>
<dl><dt>CCApplication::CCApplication()</dt><dd>m_hInstance(NULL)<br>, m_hAccelTable(NULL)<br>{<br>    m_hInstance    &#x3D; GetModuleHandle(NULL);<br>    m_nAnimationInterval.QuadPart &#x3D; 0;<br>    CC_ASSERT(! sm_pSharedApplication);<br>    sm_pSharedApplication &#x3D; this;<br>}</dd></dl><p>构造器最后一句便是将一个将 sm_pSharedApplication 变量设置为 this;也就是说，当这个类有对象实例化时，则把这个对象的指针付给 sm_pSharedApplication 变量，但是此时你会发现，CCApplication 类是从CCApplicationProtocol 类中继承下来的，CCApplicationProtocol 类是一个抽象类，包含有多个纯虚函数，在CCApplication 类内部并没有对这些纯虚函数进行实现，所以当前 CCApplication 类也是一个抽象类，无法被实例化的。这里把 this 赋值给 sm_pSharedApplication 有什么意义吗？ 在考虑这个问题之前，回想一下之前实例化的 AppDelegate的对象，该类构建时会调用父类 CCApplication 类的构造器，换个角度说，CCApplication 类无法实例化对象，但其子类是可以实例化对象的，并且其子类继承了CCApplication 类所有没有实现的纯虚函数并做了实现。在实例化对象时，这个 this 就指向了我们在main函数中看到的 app 对象。过程如下图： <a href="/images/2015/05/2015-05-17_200151.png"><img src="/images/2015/05/2015-05-17_200151.png" alt="2015-05-17_200151"></a> 此时 this 指向实例化的对象 app ，在 CCApplication 类的构造器中，将该指针赋值给了 sm_pSharedApplication 。在 CCApplication 类的成员中，我们找到了 sm_pSharedApplication 成员，他被声明为一个 static 变量，也就是在整个应用程序中，它都是有效的，得到这个结论后，我们知道了以下信息。 1、 AppDelegate 类继承了CCApplication 类并实现了所有从 CCApplicationProtocol 类中继承下来的纯虚函数。 2、当实例化一个 AppDelegate 类的对象时，调用了 CCApplication 类的构造器，将 AppDelegate 对象的指针赋值给了一个 CCApplication 类的静态的成员变量 sm_pSharedApplication。 接下来，我们再来分析最后一步：</p>
<p>return CCApplication::sharedApplication()-&gt;run();</p>
<p>首先调用了 CCApplication 类的成员方法 sharedApplication()，该方法实现如下：</p>
<p>CCApplication* CCApplication::sharedApplication()<br>{<br>    CC_ASSERT(sm_pSharedApplication);<br>    return sm_pSharedApplication;<br>}</p>
<p>它只是获取了一下静态变量 sm_pSharedApplication 的值并返回。返回后再次调用了 CCApplication 类的方法 run()，在 run() 中，调用了由 AppDelegate 类实现的方法 applicationDidFinishLaunching()：</p>
<p>&#x2F;&#x2F; Initialize instance and cocos2d.<br>if (!applicationDidFinishLaunching())<br>{<br>    return 0;<br>}</p>
<p>回想一下多态实现的三个条件。 1，是父类中有虚函数。（CCApplicationProtocol 类中多个纯虚函数） 2，子类 override(覆写)父类中的虚函数（AppDelegate 类覆写了所有纯虚函数） 3，通过己被子类对象赋值的父类指针，调用共用接口（利用静态变量 sm_pSharedApplication 做中介将AppDelegate 实例化的对象指针通过 this 的方式存放到 sm_pSharedApplication 中，最后借用成员函数 run() 调用了共用接口 applicationDidFinishLaunching()） 以上便是coco2dx利用多态的特性构建的一个程序入口。不得不感叹真的是把C++玩飞了。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2015/05/25/2015/2015-05-25_162110-253/,Dylan's blog,cocos2dx 入口分析,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/05/26/2015/2015-05-26_223115-258/" title="线性表顺序储存">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/05/25/2015/2015-05-25_161439-182/" title="自实现 MyString 类">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>