<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>“虚函数表”推演及多态的原理 · Dylan's blog</title><meta name="description" content="C++ 的多态性据前辈们所说，是非常难以理解的一部分内容，虽然他实现很简单，但是套用到各种设计模式后，你会非常难以理解，但无论怎样，笔者始终认为，如果了解了内部的实现原理，实际就不会那么难了。本文将介绍虚函数表的相关内容，阐述了它与多态之间难以割舍的关系。

默认情况下，一个没有任何成员变量的类，大"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>“虚函数表”推演及多态的原理</a></h3></div><div class="post-content"><p>C++ 的多态性据前辈们所说，是非常难以理解的一部分内容，虽然他实现很简单，但是套用到各种设计模式后，你会非常难以理解，但无论怎样，笔者始终认为，如果了解了内部的实现原理，实际就不会那么难了。本文将介绍虚函数表的相关内容，阐述了它与多态之间难以割舍的关系。</p>
<span id="more"></span>
<p>默认情况下，一个没有任何成员变量的类，大小是 1 个字节，如下所示：</p>
<p>#include <iostream><br> <br>using namespace std;<br> <br>class A<br>{<br>public:<br>    void func()<br>    {<br>        ;<br>    }<br>};<br> <br>int main(int argc, char* argv[])<br>{<br>    cout &lt;&lt; “class A size &#x3D; “ &lt;&lt; sizeof(A) &lt;&lt; endl;<br>    return 0;</p>
<p>}</p>
<p><a href="/images/2015/05/2015-05-25_112335.png"><img src="/images/2015/05/2015-05-25_112335.png" alt="2015-05-25_112335"></a> 给 func 函数增加一个 virtual 关键字后，class A 的大小就变成了 4 个字节。</p>
<p>#include <iostream><br> <br>using namespace std;<br> <br>class A<br>{<br>public:<br>    virtual void func()<br>    {<br>        ;<br>    }<br>};<br> <br>int main(int argc, char* argv[])<br>{<br>    cout &lt;&lt; “class A size &#x3D; “ &lt;&lt; sizeof(A) &lt;&lt; endl;<br>    return 0;<br>}</p>
<p><a href="/images/2015/05/2015-05-25_112555.png"><img src="/images/2015/05/2015-05-25_112555.png" alt="2015-05-25_112555"></a> 这中间多了什么东西？使用VS调试一下我们可以看到，a对象中，多了一个成员，是_vfptr，如下图： <a href="/images/2015/05/2015-05-25_112954.png"><img src="/images/2015/05/2015-05-25_112954.png" alt="2015-05-25_112954"></a> 这是一个函数指针数组，里面包含了所有类中虚函数的指针。我们案例中只有一个虚函数，所以只看到一个，如果我们多写几个虚函数的话，就能在这个数组中看到多个函数指针。如下图： <a href="/images/2015/05/2015-05-25_113346.png"><img src="/images/2015/05/2015-05-25_113346.png" alt="2015-05-25_113346"></a> 我们称之为这个内建的隐藏数组为 “虚函数表” （virtual Table、v-Table）。下图为该函数表的形象图： <a href="/images/2015/05/2015-05-25_123821.png"><img src="/images/2015/05/2015-05-25_123821.png" alt="2015-05-25_123821"></a> <strong>【代码推演】</strong></p>
<p>#include <iostream><br> <br>using namespace std;<br> <br>class A<br>{<br>public:<br>    virtual void func(){ cout &lt;&lt; “class A func” &lt;&lt; endl; }<br>    virtual void func1(){ cout &lt;&lt; “class A func1” &lt;&lt; endl; }<br>    virtual void func2(){ cout &lt;&lt; “class A func2” &lt;&lt; endl; }<br>};<br> <br>int main(int argc, char* argv[])<br>{<br>    A a;<br> <br>    typedef void(*Fun)();<br>    Fun pFun &#x3D; NULL;<br> <br>    cout &lt;&lt; “object a address &#x3D; “ &lt;&lt; &amp;a &lt;&lt; endl;<br> <br>    &#x2F;&#x2F; 虚函数表的地址存放在类对象内存的最起始位置的 4 个字节处<br>    &#x2F;&#x2F; 而 &amp;a 是一个对象，他的大小由类中的成员决定<br>    &#x2F;&#x2F; 我们只想要前 4 个字节里面的内容<br>    &#x2F;&#x2F; 所以把强制转换成 int* 类型        (int*)&amp;a<br>    &#x2F;&#x2F; 再打印解引用后的内容，就得出了前 4 个字节里面存放的数据。    *((int*)&amp;a)<br>    &#x2F;&#x2F; 这个内容被解引用后会被解释成 int 类型的数据，而非 int* 类型<br>    &#x2F;&#x2F; 所以还需要再强制转换一次为 int*    (int*) (*((int*)&amp;a))<br>    &#x2F;&#x2F; 最后得出的就是 4 个字节的虚函数表 _vfptr 的起始地址<br> <br>    cout &lt;&lt; “object a _vfptr address &#x3D; “ &lt;&lt; (int*)(*((int*)&amp;a)) &lt;&lt; endl;<br> <br>    &#x2F;&#x2F; 得到了虚函数表的起始地址后想调用表中的第一个函数<br>    &#x2F;&#x2F; 就需要对地址解引用，得出第一个函数的地址  *((int*)(*((int*)&amp;a)))<br>    &#x2F;&#x2F; 然后将其强制转换为一个函数指针，进行调用<br> <br>    cout &lt;&lt; “_vfptr func address &#x3D; “ &lt;&lt; (int*) *((int*)(*((int*)&amp;a)) + 0) &lt;&lt; “\t\t”;<br>    pFun &#x3D; (Fun) *((int*)(*((int*)&amp;a)));<br>    pFun();<br> <br>    &#x2F;&#x2F; 如果想调用第二个函数，那么在这个地址的基础上+1就得到了第二个函数的地址<br> <br>    cout &lt;&lt; “_vfptr func1 address &#x3D; “ &lt;&lt; (int*) *((int*)(*((int*)&amp;a)) + 1) &lt;&lt; “\t\t”;<br>    pFun &#x3D; (Fun) *((int*)(*((int*)&amp;a)) + 1);<br>    pFun();<br> <br>    &#x2F;&#x2F; 一次类推，+2就得到了第三个函数的地址<br> <br>    cout &lt;&lt; “_vfptr func2 address &#x3D; “ &lt;&lt; (int*) *((int*)(*((int*)&amp;a)) + 2) &lt;&lt; “\t\t”;<br>    pFun &#x3D; (Fun) *((int*)(*((int*)&amp;a)) + 2);<br>    pFun();<br> <br>    return 0;</p>
<p>}</p>
<p><a href="/images/2015/05/2015-05-25_122221.png"><img src="/images/2015/05/2015-05-25_122221.png" alt="2015-05-25_122221"></a> 以上，我们只是证实了一下虚函数表的存在，并通过间接的手段调用了一次虚函数表里面的函数。当然我们并不是单纯的只是让大家知道他的存在，而是结合虚函数表，引导大家学习多态的实现。 我们写了一个子类，继承了类 A，并且，在子类中编写了一个与类 A 中同名、同返回值、同参数（同类型、同位置）的函数 func，如下：</p>
<p>class B : public A<br>{<br>public:<br>    void func(){ cout &lt;&lt; “class B func” &lt;&lt; endl; }</p>
<p>};</p>
<p>此时，我们生成一个类 B 的对象，当这个对象构造完毕时，我们再次调试查看它继承的类 A 中的虚函数表中的内容。 <a href="/images/2015/05/2015-05-25_144409.png"><img src="/images/2015/05/2015-05-25_144409.png" alt="2015-05-25_144409"></a> 很明显我们发现，继承下来的类 A 中的虚函数表第一个函数变成了 B::func，实际上，这个操作只是将虚函数表中的函数指针进行了覆盖。这种方式我们就称为覆写。当你使用子类对象初始化一个父类的指针时。这个指针在调用 func 函数时，会优先遍历虚函数表，如果发现同名函数，则调用之。如果没有发现再到非虚函数表以外的成员方法中寻找。这便是**“多态”**</p>
<p>&#x2F;&#x2F; 会调用已经覆写的 B 类的 func 函数<br>A *pb &#x3D; new B;<br>pb-&gt;func();</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2015/05/25/2015/2015-05-25_155116-229/,Dylan's blog,“虚函数表”推演及多态的原理,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/05/25/2015/2015-05-25_155324-239/" title="函数模版与类模版">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/05/25/2015/2015-05-25_154348-225/" title="抽象类纯虚函数与虚析构">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>