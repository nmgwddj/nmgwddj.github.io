<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>数组堆排序 · Dylan's blog</title><meta name="description" content="堆排序也是一种空间换时间的做法，速度相对较快，我们需要生成一个动态的临时数组，以二叉堆的格式将数据插入到数组中，表现形式如下图：

 这个二叉堆是一个完全二叉树或一个近似完全的二叉树，要满足以下两点特性：
【二叉堆概念】
父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。
每个节点的左子"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>数组堆排序</a></h3></div><div class="post-content"><p>堆排序也是一种空间换时间的做法，速度相对较快，我们需要生成一个动态的临时数组，以二叉堆的格式将数据插入到数组中，表现形式如下图：</p>
<span id="more"></span>
<p><a href="/images/2015/06/2015-06-12_115119.png"><img src="/images/2015/06/2015-06-12_115119.png" alt="2015-06-12_115119"></a> 这个二叉堆是一个完全二叉树或一个近似完全的二叉树，要满足以下两点特性：</p>
<h3 id="【二叉堆概念】"><a href="#【二叉堆概念】" class="headerlink" title="【二叉堆概念】"></a>【二叉堆概念】</h3><ul>
<li>父节点的键值总是大于或等于（小于或等于）任何一个子节点的键值。</li>
<li>每个节点的左子树和右子树都是一个二叉堆（都是最大堆或最小堆）</li>
</ul>
<h3 id="【最大堆最小堆概念】"><a href="#【最大堆最小堆概念】" class="headerlink" title="【最大堆最小堆概念】"></a>【最大堆最小堆概念】</h3><ul>
<li>父节点的键值总是大于或等于子节点的键值时为最大堆（大顶堆）</li>
<li>父节点的键值总是小于或等于子节点的键值时为最小堆（小顶堆）</li>
</ul>
<hr>
<p>了解以上概念后，我们就要清楚堆排序的过程了，首先我们要将数据按一定格式（比如按大顶堆或者小顶堆的格式）插入到二叉堆中，在插入过程中要对数据进行对比排序。全部插入完成后，将二叉堆中的根节点的数值依次取出，取出的同时，将堆中最后一个数据覆盖到根节点，再将这个数据与所有子节点对比，最终把最大（或最小）的子节点移动到根节点的位置。这样保证每次取出的数据都是最大（或最小）的数据。表现形式如下：</p>
<h3 id="【插入元素】"><a href="#【插入元素】" class="headerlink" title="【插入元素】"></a>【插入元素】</h3><p>插入元素的步骤</p>
<ol>
<li>先将此元素插入添加到完全二叉树的最后面的位置(数组的最后), 此完全二叉树多了一个叶子节点.</li>
<li>求出此叶子节点的父节点, 与其父节点进行比较, 如果比父节点大则二者交换位置</li>
<li>重复步骤2</li>
<li>节点插入完成</li>
</ol>
<p><a href="/images/2015/06/2015-06-12_120159.png"><img src="/images/2015/06/2015-06-12_120159.png" alt="2015-06-12_120159"></a></p>
<h3 id="【弹出元素】"><a href="#【弹出元素】" class="headerlink" title="【弹出元素】"></a>【弹出元素】</h3><p>弹出元素步骤</p>
<ol>
<li>删除根节点</li>
<li>将最后一个叶子节点放到根节点的位置</li>
<li>新的根节点分别与其左右孩子比较,如果比根节点大, 选出较大的一个</li>
<li>将根节点与值较大的叶子节点交换位置</li>
<li>发生交换的孩子节点如果还有子节点, 重复3, 4步</li>
</ol>
<p><a href="/images/2015/06/2015-06-12_120518.png"><img src="/images/2015/06/2015-06-12_120518.png" alt="2015-06-12_120518"></a></p>
<h3 id="【实现代码】"><a href="#【实现代码】" class="headerlink" title="【实现代码】"></a>【实现代码】</h3><p>#include &lt;stdio.h&gt;<br>#include &lt;stdlib.h&gt;</p>
<p>typedef struct _tag_heapTag<br>{<br>&#x2F;&#x2F; 指向数据的指针，用于创建动态数组存储数据<br>int *arrList;<br>&#x2F;&#x2F; 记录当前堆中的节点个数<br>int nSize;<br>}MyHeap;</p>
<p>int PopMaxValue(MyHeap* pHeap)<br>{<br>int nPos &#x3D; 1;<br>&#x2F;&#x2F; 记录根节点最大值，用于返回值<br>int nMax &#x3D; pHeap-&gt;arrList[nPos];<br>&#x2F;&#x2F; 把数组最后的值挪动到根节点的位置，并记录下挪动过来的值<br>int nTemp &#x3D; pHeap-&gt;arrList[nPos] &#x3D; pHeap-&gt;arrList[pHeap-&gt;nSize];</p>
<p>&#x2F;&#x2F; 得到根节点的子节点的位置<br>int nChild &#x3D; nPos * 2;<br>while (nChild &lt;&#x3D; pHeap-&gt;nSize)<br>{<br>&#x2F;&#x2F; 判断右子节点的下标不超过数组长度<br>if (nChild + 1 &lt;&#x3D; pHeap-&gt;nSize &amp;&amp;<br>&#x2F;&#x2F; 判断右子节点是否大于左子节点<br>pHeap-&gt;arrList[nChild] &lt; pHeap-&gt;arrList[nChild + 1])<br>{<br>&#x2F;&#x2F; 如果右子节点大于左子节点，那么让子节点位置等于右子节点<br>nChild++;<br>}<br>&#x2F;&#x2F; 根节点的值是最大的，无需交换了<br>if (pHeap-&gt;arrList[nPos] &gt; pHeap-&gt;arrList[nChild])<br>break;</p>
<p>&#x2F;&#x2F; 如果小于，那么交换子节点和当前根节点的值<br>pHeap-&gt;arrList[nPos] &#x3D; pHeap-&gt;arrList[nChild];<br>&#x2F;&#x2F; 让根节点等于被交换前原子节点的位置<br>nPos &#x3D; nChild;<br>&#x2F;&#x2F; 计算出交换后节点位置下的子节点的位置，用于下次循环<br>nChild *&#x3D; 2;<br>}</p>
<p>&#x2F;&#x2F; 退出循环后nPos的位置一定是最下面叶子节点的位置，把之前备份的值赋值给它<br>pHeap-&gt;arrList[nPos] &#x3D; nTemp;<br>&#x2F;&#x2F; 数组长度–<br>pHeap-&gt;nSize–;</p>
<p>&#x2F;&#x2F; 返回被删除的数据<br>return nMax;<br>}</p>
<p>int InsertKey(MyHeap* pHeap, int nPos)<br>{<br>while (nPos &gt; 1)<br>{<br>&#x2F;&#x2F; 记录下当前nPos节点值<br>int nMax &#x3D; pHeap-&gt;arrList[nPos];<br>&#x2F;&#x2F; 父节点下标<br>int nParent &#x3D; nPos &#x2F; 2;<br>if (nMax &gt; pHeap-&gt;arrList[nParent])<br>{<br>&#x2F;&#x2F; 交换子节点和父节点的值<br>pHeap-&gt;arrList[nPos] &#x3D; pHeap-&gt;arrList[nParent];<br>pHeap-&gt;arrList[nParent] &#x3D; nMax;<br>&#x2F;&#x2F; 记录父节点的位置给nPos，用于下次循环<br>nPos &#x3D; nParent;<br>}<br>else<br>{<br>&#x2F;&#x2F; 子节点已经不大于父节点的值<br>break;<br>}<br>}<br>return 0;<br>}</p>
<p>void Insert(MyHeap* pHeap, int nData)<br>{<br>pHeap-&gt;nSize++;<br>pHeap-&gt;arrList[pHeap-&gt;nSize] &#x3D; nData;<br>&#x2F;&#x2F; 比较，向上渗透<br>InsertKey(pHeap, pHeap-&gt;nSize);<br>}</p>
<p>void heapSort(int arr[], int len)<br>{<br>MyHeap myHeap;<br>&#x2F;&#x2F; 给插入数据的数组空间分配内存，因为要跳过下标为0的元素<br>&#x2F;&#x2F; 所以长度要是传递进来的数组长度 + 1的大小<br>myHeap.arrList &#x3D; (int*)malloc(sizeof(int) * (len + 1));<br>myHeap.nSize &#x3D; 0;</p>
<p>for (int i &#x3D; 1; i &lt;&#x3D; len; i++)<br>{<br>&#x2F;&#x2F; 一次将数组中的元素插入动态分配的数组<br>Insert(&amp;myHeap, arr[i - 1]);<br>}</p>
<p>&#x2F;&#x2F; 弹出数据并打印弹出的值<br>for (int i &#x3D; 1; i &lt;&#x3D; len; i++)<br>{<br>printf(“%d “, PopMaxValue(&amp;myHeap));<br>}<br>&#x2F;&#x2F; 释放申请的空间<br>free(myHeap.arrList);<br>}</p>
<p>int main(int argc, char* argv[])<br>{<br>int arr[] &#x3D; { 12, 5, 33, 6, 10 };<br>int len &#x3D; sizeof(arr) &#x2F; sizeof(int);<br>printf(“待排序数组序列: “);<br>for (int i &#x3D; 0; i &lt; len; ++i)<br>{<br>printf(“%d\t”, arr[i]);<br>}<br>putchar(10);</p>
<p>&#x2F;&#x2F;遍历<br>printf(“堆排序之后的序列: “);<br>heapSort(arr, len);<br>putchar(10);<br>return 0;<br>}</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-06-12</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/tags/排序/" title="排序">排序 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2015/06/12/2015/2015-06-12_120613-467/,Dylan's blog,数组堆排序,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/06/12/2015/2015-06-12_143128-472/" title="算法效率的度量">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/06/12/2015/2015-06-12_001138-461/" title="数组归并排序">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>