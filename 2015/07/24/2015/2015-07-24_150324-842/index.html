<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>oracle proc 编程基础及最小化案例 | Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>oracle proc 编程基础及最小化案例</h1>
    </header>

    <section>
      <p>oracle proc 编程是在我的概念中是非常陌生的，学习了一天下来发现这东西真的好古老，但是依然健壮、稳定，其中间是编辑一个 .pc 的文件使用 proc 进行预处理，预处理后生成一个真正的.c文件，此时再由 gcc 去编译成一个可执行文件运行。因为 proc 涉及到的知识较多，我无法整理到几篇博文中就概述这些所涉及的知识，所以只能总结代码做好注释防止以后自己需要时忘记。如果有想进一步了解 proc 编程的，可以买名为“Oracle9I ProC C++编程指南”。包括 oracle 的环境搭建也并不是我们讨论的重点，如果有精力的话，我会给大家编写类似的教程。</p>
<span id="more"></span>
<hr>
<p> </p>
<h3 id="最小化实现代码"><a href="#最小化实现代码" class="headerlink" title="最小化实现代码"></a>最小化实现代码</h3><p>#include &lt;stdio.h&gt;<br>#include “sqlca.h”&#x2F;&#x2F; 包含 proc 头文件</p>
<p>EXEC SQL BEGIN DECLARE SECTION;<br>char* serversid &#x3D; “scott&#x2F;tiger@orcl”;&#x2F;&#x2F; 定义宿主变量<br>EXEC SQL END DECLARE SECTION;</p>
<p>int main(int argc, char* argv)<br>{<br>int ret &#x3D; 0;<br>printf(“connect server str &#x3D; %s\n”, serversid);</p>
<p>EXEC SQL connect :serversid;&#x2F;&#x2F; 连接服务器<br>if (sqlca.sqlcode !&#x3D; 0)&#x2F;&#x2F; 错误处理机制，后文会有详细介绍<br>{<br>ret &#x3D; sqlca.sqlcode;<br>printf(“connect error…errcode &#x3D; %d\n”, ret);<br>return ret;<br>}</p>
<p>printf(“connect oracler server success…\n”);<br>EXEC SQL commit release;&#x2F;&#x2F; 提交并关闭连接<br>return 0;<br>}</p>
<p>使用 proc 命令进行编译，编译结果如下：</p>
<p>[oracle@localhost 0723]$ proc hello.pc</p>
<p>Pro*C&#x2F;C++: Release 11.2.0.1.0 - Production on Fri Jul 24 13:20:03 2015</p>
<p>Copyright (c) 1982, 2009, Oracle and&#x2F;or its affiliates.  All rights reserved.</p>
<p>System default option values taken from: &#x2F;home&#x2F;oracle_11&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;precomp&#x2F;admin&#x2F;pcscfg.cfg</p>
<p>此时会在当前目录下生成一个预处理过的 .c 文件，.c文件的内容如下：</p>
<p>&#x2F;* Result Sets Interface *&#x2F;<br>#ifndef SQL_CRSR</p>
<h1 id="define-SQL-CRSR"><a href="#define-SQL-CRSR" class="headerlink" title="define SQL_CRSR"></a>define SQL_CRSR</h1><p>  struct sql_cursor<br>  {<br>    unsigned int curocn;<br>    void *ptr1;<br>    void *ptr2;<br>    unsigned int magic;<br>  };<br>  typedef struct sql_cursor sql_cursor;<br>  typedef struct sql_cursor SQL_CURSOR;<br>#endif &#x2F;* SQL_CRSR *&#x2F;</p>
<p>&#x2F;* Thread Safety *&#x2F;<br>typedef void * sql_context;<br>typedef void * SQL_CONTEXT;</p>
<p>&#x2F;* Object support *&#x2F;<br>struct sqltvn<br>{<br>  unsigned char *tvnvsn;<br>  unsigned short tvnvsnl;<br>  unsigned char *tvnnm;<br>  unsigned short tvnnml;<br>  unsigned char *tvnsnm;<br>  unsigned short tvnsnml;<br>};<br>typedef struct sqltvn sqltvn;</p>
<p>struct sqladts<br>{<br>  unsigned int adtvsn;<br>  unsigned short adtmode;<br>  unsigned short adtnum;<br>  sqltvn adttvn[1];<br>};<br>typedef struct sqladts sqladts;</p>
<p>static struct sqladts sqladt &#x3D; {<br>  1,1,0,<br>};</p>
<p>&#x2F;* Binding to PL&#x2F;SQL Records *&#x2F;<br>struct sqltdss<br>{<br>  unsigned int tdsvsn;<br>  unsigned short tdsnum;<br>  unsigned char *tdsval[1];<br>};<br>typedef struct sqltdss sqltdss;<br>static struct sqltdss sqltds &#x3D;<br>{<br>  1,<br>  0,<br>};</p>
<p>&#x2F;* File name &amp; Package Name *&#x2F;<br>struct sqlcxp<br>{<br>  unsigned short fillen;<br>           char  filnam[9];<br>};<br>static struct sqlcxp sqlfpn &#x3D;<br>{<br>    8,<br>    “hello.pc”<br>};</p>
<p>static unsigned int sqlctx &#x3D; 18323;</p>
<p>static struct sqlexd {<br>   unsigned long  sqlvsn;<br>   unsigned int   arrsiz;<br>   unsigned int   iters;<br>   unsigned int   offset;<br>   unsigned short selerr;<br>   unsigned short sqlety;<br>   unsigned int   occurs;<br>            short *cud;<br>   unsigned char  *sqlest;<br>            char  *stmt;<br>   sqladts *sqladtp;<br>   sqltdss *sqltdsp;<br>   unsigned char  **sqphsv;<br>   unsigned long  *sqphsl;<br>            int   *sqphss;<br>            short **sqpind;<br>            int   *sqpins;<br>   unsigned long  *sqparm;<br>   unsigned long  **sqparc;<br>   unsigned short  *sqpadto;<br>   unsigned short  *sqptdso;<br>   unsigned int   sqlcmax;<br>   unsigned int   sqlcmin;<br>   unsigned int   sqlcincr;<br>   unsigned int   sqlctimeout;<br>   unsigned int   sqlcnowait;<br>            int   sqfoff;<br>   unsigned int   sqcmod;<br>   unsigned int   sqfmod;<br>   unsigned char  *sqhstv[4];<br>   unsigned long  sqhstl[4];<br>            int   sqhsts[4];<br>            short *sqindv[4];<br>            int   sqinds[4];<br>   unsigned long  sqharm[4];<br>   unsigned long  *sqharc[4];<br>   unsigned short  sqadto[4];<br>   unsigned short  sqtdso[4];<br>} sqlstm &#x3D; {12,4};</p>
<p>&#x2F;* SQLLIB Prototypes *&#x2F;<br>extern sqlcxt ( void **, unsigned int *,<br>                   struct sqlexd *, struct sqlcxp * );<br>extern sqlcx2t( void **, unsigned int *,<br>                   struct sqlexd *, struct sqlcxp * );<br>extern sqlbuft( void **, char * );<br>extern sqlgs2t( void **, char * );<br>extern sqlorat( void **, unsigned int *, void * );</p>
<p>&#x2F;* Forms Interface *&#x2F;<br>static int IAPSUCC &#x3D; 0;<br>static int IAPFAIL &#x3D; 1403;<br>static int IAPFTL  &#x3D; 535;<br>extern void sqliem( unsigned char *, signed int * );</p>
<p>typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;<br>typedef struct { unsigned short len; unsigned char arr[1]; } varchar;</p>
<p>&#x2F;* CUD (Compilation Unit Data) Array *&#x2F;<br>static short sqlcud0[] &#x3D;<br>{12,4130,1,0,0,<br>5,0,0,0,0,0,27,13,0,0,4,4,0,1,0,1,97,0,0,1,10,0,0,1,10,0,0,1,10,0,0,<br>36,0,0,2,0,0,30,22,0,0,0,0,0,1,0,<br>};</p>
<p>#include &lt;stdio.h&gt;<br>#include “sqlca.h”</p>
<p>&#x2F;* EXEC SQL BEGIN DECLARE SECTION; *&#x2F; </p>
<p>char* serversid &#x3D; “scott&#x2F;tiger@orcl”;&#x2F;&#x2F; 定义宿主变量<br>&#x2F;* EXEC SQL END DECLARE SECTION; *&#x2F; </p>
<p>int main(int argc, char* argv[])<br>{<br>int ret &#x3D; 0;<br>printf(“serversid: %s\n”, serversid);&#x2F;&#x2F; 打印一下服务器的连接地址字符串</p>
<p>&#x2F;* EXEC SQL CONNECT :serversid; *&#x2F; </p>
<p>{<br> struct sqlexd sqlstm;<br> sqlstm.sqlvsn &#x3D; 12;<br> sqlstm.arrsiz &#x3D; 4;<br> sqlstm.sqladtp &#x3D; &amp;sqladt;<br> sqlstm.sqltdsp &#x3D; &amp;sqltds;<br> sqlstm.iters &#x3D; (unsigned int  )10;<br> sqlstm.offset &#x3D; (unsigned int  )5;<br> sqlstm.cud &#x3D; sqlcud0;<br> sqlstm.sqlest &#x3D; (unsigned char  *)&amp;sqlca;<br> sqlstm.sqlety &#x3D; (unsigned short)4352;<br> sqlstm.occurs &#x3D; (unsigned int  )0;<br> sqlstm.sqhstv[0] &#x3D; (unsigned char  *)serversid;<br> sqlstm.sqhstl[0] &#x3D; (unsigned long )0;<br> sqlstm.sqhsts[0] &#x3D; (         int  )0;<br> sqlstm.sqindv[0] &#x3D; (         short *)0;<br> sqlstm.sqinds[0] &#x3D; (         int  )0;<br> sqlstm.sqharm[0] &#x3D; (unsigned long )0;<br> sqlstm.sqadto[0] &#x3D; (unsigned short )0;<br> sqlstm.sqtdso[0] &#x3D; (unsigned short )0;<br> sqlstm.sqphsv &#x3D; sqlstm.sqhstv;<br> sqlstm.sqphsl &#x3D; sqlstm.sqhstl;<br> sqlstm.sqphss &#x3D; sqlstm.sqhsts;<br> sqlstm.sqpind &#x3D; sqlstm.sqindv;<br> sqlstm.sqpins &#x3D; sqlstm.sqinds;<br> sqlstm.sqparm &#x3D; sqlstm.sqharm;<br> sqlstm.sqparc &#x3D; sqlstm.sqharc;<br> sqlstm.sqpadto &#x3D; sqlstm.sqadto;<br> sqlstm.sqptdso &#x3D; sqlstm.sqtdso;<br> sqlstm.sqlcmax &#x3D; (unsigned int )100;<br> sqlstm.sqlcmin &#x3D; (unsigned int )2;<br> sqlstm.sqlcincr &#x3D; (unsigned int )1;<br> sqlstm.sqlctimeout &#x3D; (unsigned int )0;<br> sqlstm.sqlcnowait &#x3D; (unsigned int )0;<br> sqlcxt((void **)0, &amp;sqlctx, &amp;sqlstm, &amp;sqlfpn);<br>}</p>
<p>&#x2F;&#x2F; 连接服务器<br>if (sqlca.sqlcode !&#x3D; 0)&#x2F;&#x2F; 容错处理，后面会有更详细的文章介绍<br>{<br>ret &#x3D; sqlca.sqlcode;<br>printf(“connect oracle error… code &#x3D; %d\n”, ret);<br>return ret;<br>}</p>
<p>printf(“connect oracle success…\n”);<br>&#x2F;* EXEC SQL COMMIT RELEASE; *&#x2F; </p>
<p>{<br> struct sqlexd sqlstm;<br> sqlstm.sqlvsn &#x3D; 12;<br> sqlstm.arrsiz &#x3D; 4;<br> sqlstm.sqladtp &#x3D; &amp;sqladt;<br> sqlstm.sqltdsp &#x3D; &amp;sqltds;<br> sqlstm.iters &#x3D; (unsigned int  )1;<br> sqlstm.offset &#x3D; (unsigned int  )36;<br> sqlstm.cud &#x3D; sqlcud0;<br> sqlstm.sqlest &#x3D; (unsigned char  *)&amp;sqlca;<br> sqlstm.sqlety &#x3D; (unsigned short)4352;<br> sqlstm.occurs &#x3D; (unsigned int  )0;<br> sqlcxt((void **)0, &amp;sqlctx, &amp;sqlstm, &amp;sqlfpn);<br>}</p>
<p>&#x2F;&#x2F; 提交(commit)并关闭(release)连接</p>
<p>return 0;<br>}</p>
<p>这是由 proc 预处理过后的 .c 文件，只不过是将我们之前编写的 pc 文件中的一些 EXE SQL … 等关键字替换成了真正的 c 语言执行语句。最后我们需要使用 gcc 来编译它。如果你直接编译的话，会收到如下报错：</p>
<p>[oracle@localhost 0723]$ gcc hello.c -o hello<br>&#x2F;tmp&#x2F;cchZbCeQ.o: In function `main’:<br>hello.c:(.text+0x86): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x1ed): undefined reference to `sqlcxt’<br>hello.c:(.text+0x1f2): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x200): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x27f): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x2b7): undefined reference to `sqlcxt’</p>
<p>这提示的意思是找不到动态库，所以我们需要手动指定动态库和头文件所在路径。正确的编译方法如下：</p>
<p>gcc hello.c -o hello -I $ORACLE_HOME&#x2F;precomp&#x2F;public -L $ORACLE_HOME&#x2F;lib -l clntsh</p>
<p>编译完成后运行程序，如果提示连接成功，那么证明你的程序就可以正常连接 oracle 服务器了：</p>
<p>[oracle@localhost 0723]$ .&#x2F;hello<br>serversid: scott&#x2F;tiger@orcl<br>connect oracle success…</p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2015-07-24T15:03:24.000Z" itemprop="datePublished">
              2015-07-24
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/oracle/">oracle</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>