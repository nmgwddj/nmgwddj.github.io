<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>oracle proc 编程基础及最小化案例 · Dylan's blog</title><meta name="description" content="oracle proc 编程是在我的概念中是非常陌生的，学习了一天下来发现这东西真的好古老，但是依然健壮、稳定，其中间是编辑一个 .pc 的文件使用 proc 进行预处理，预处理后生成一个真正的.c文件，此时再由 gcc 去编译成一个可执行文件运行。因为 proc 涉及到的知识较多，我无法整理到几篇"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 8.1.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>oracle proc 编程基础及最小化案例</a></h3></div><div class="post-content"><p>oracle proc 编程是在我的概念中是非常陌生的，学习了一天下来发现这东西真的好古老，但是依然健壮、稳定，其中间是编辑一个 .pc 的文件使用 proc 进行预处理，预处理后生成一个真正的.c文件，此时再由 gcc 去编译成一个可执行文件运行。因为 proc 涉及到的知识较多，我无法整理到几篇博文中就概述这些所涉及的知识，所以只能总结代码做好注释防止以后自己需要时忘记。如果有想进一步了解 proc 编程的，可以买名为“Oracle9I ProC C++编程指南”。包括 oracle 的环境搭建也并不是我们讨论的重点，如果有精力的话，我会给大家编写类似的教程。</p>
<span id="more"></span>
<hr>
<p> </p>
<h3 id="最小化实现代码"><a href="#最小化实现代码" class="headerlink" title="最小化实现代码"></a>最小化实现代码</h3><p>#include &lt;stdio.h&gt;<br>#include “sqlca.h”&#x2F;&#x2F; 包含 proc 头文件</p>
<p>EXEC SQL BEGIN DECLARE SECTION;<br>char* serversid &#x3D; “scott&#x2F;tiger@orcl”;&#x2F;&#x2F; 定义宿主变量<br>EXEC SQL END DECLARE SECTION;</p>
<p>int main(int argc, char* argv)<br>{<br>int ret &#x3D; 0;<br>printf(“connect server str &#x3D; %s\n”, serversid);</p>
<p>EXEC SQL connect :serversid;&#x2F;&#x2F; 连接服务器<br>if (sqlca.sqlcode !&#x3D; 0)&#x2F;&#x2F; 错误处理机制，后文会有详细介绍<br>{<br>ret &#x3D; sqlca.sqlcode;<br>printf(“connect error…errcode &#x3D; %d\n”, ret);<br>return ret;<br>}</p>
<p>printf(“connect oracler server success…\n”);<br>EXEC SQL commit release;&#x2F;&#x2F; 提交并关闭连接<br>return 0;<br>}</p>
<p>使用 proc 命令进行编译，编译结果如下：</p>
<p>[oracle@localhost 0723]$ proc hello.pc</p>
<p>Pro*C&#x2F;C++: Release 11.2.0.1.0 - Production on Fri Jul 24 13:20:03 2015</p>
<p>Copyright (c) 1982, 2009, Oracle and&#x2F;or its affiliates.  All rights reserved.</p>
<p>System default option values taken from: &#x2F;home&#x2F;oracle_11&#x2F;app&#x2F;oracle&#x2F;product&#x2F;11.2.0&#x2F;db_1&#x2F;precomp&#x2F;admin&#x2F;pcscfg.cfg</p>
<p>此时会在当前目录下生成一个预处理过的 .c 文件，.c文件的内容如下：</p>
<p>&#x2F;* Result Sets Interface *&#x2F;<br>#ifndef SQL_CRSR</p>
<h1 id="define-SQL-CRSR"><a href="#define-SQL-CRSR" class="headerlink" title="define SQL_CRSR"></a>define SQL_CRSR</h1><p>  struct sql_cursor<br>  {<br>    unsigned int curocn;<br>    void *ptr1;<br>    void *ptr2;<br>    unsigned int magic;<br>  };<br>  typedef struct sql_cursor sql_cursor;<br>  typedef struct sql_cursor SQL_CURSOR;<br>#endif &#x2F;* SQL_CRSR *&#x2F;</p>
<p>&#x2F;* Thread Safety *&#x2F;<br>typedef void * sql_context;<br>typedef void * SQL_CONTEXT;</p>
<p>&#x2F;* Object support *&#x2F;<br>struct sqltvn<br>{<br>  unsigned char *tvnvsn;<br>  unsigned short tvnvsnl;<br>  unsigned char *tvnnm;<br>  unsigned short tvnnml;<br>  unsigned char *tvnsnm;<br>  unsigned short tvnsnml;<br>};<br>typedef struct sqltvn sqltvn;</p>
<p>struct sqladts<br>{<br>  unsigned int adtvsn;<br>  unsigned short adtmode;<br>  unsigned short adtnum;<br>  sqltvn adttvn[1];<br>};<br>typedef struct sqladts sqladts;</p>
<p>static struct sqladts sqladt &#x3D; {<br>  1,1,0,<br>};</p>
<p>&#x2F;* Binding to PL&#x2F;SQL Records *&#x2F;<br>struct sqltdss<br>{<br>  unsigned int tdsvsn;<br>  unsigned short tdsnum;<br>  unsigned char *tdsval[1];<br>};<br>typedef struct sqltdss sqltdss;<br>static struct sqltdss sqltds &#x3D;<br>{<br>  1,<br>  0,<br>};</p>
<p>&#x2F;* File name &amp; Package Name *&#x2F;<br>struct sqlcxp<br>{<br>  unsigned short fillen;<br>           char  filnam[9];<br>};<br>static struct sqlcxp sqlfpn &#x3D;<br>{<br>    8,<br>    “hello.pc”<br>};</p>
<p>static unsigned int sqlctx &#x3D; 18323;</p>
<p>static struct sqlexd {<br>   unsigned long  sqlvsn;<br>   unsigned int   arrsiz;<br>   unsigned int   iters;<br>   unsigned int   offset;<br>   unsigned short selerr;<br>   unsigned short sqlety;<br>   unsigned int   occurs;<br>            short *cud;<br>   unsigned char  *sqlest;<br>            char  *stmt;<br>   sqladts *sqladtp;<br>   sqltdss *sqltdsp;<br>   unsigned char  **sqphsv;<br>   unsigned long  *sqphsl;<br>            int   *sqphss;<br>            short **sqpind;<br>            int   *sqpins;<br>   unsigned long  *sqparm;<br>   unsigned long  **sqparc;<br>   unsigned short  *sqpadto;<br>   unsigned short  *sqptdso;<br>   unsigned int   sqlcmax;<br>   unsigned int   sqlcmin;<br>   unsigned int   sqlcincr;<br>   unsigned int   sqlctimeout;<br>   unsigned int   sqlcnowait;<br>            int   sqfoff;<br>   unsigned int   sqcmod;<br>   unsigned int   sqfmod;<br>   unsigned char  *sqhstv[4];<br>   unsigned long  sqhstl[4];<br>            int   sqhsts[4];<br>            short *sqindv[4];<br>            int   sqinds[4];<br>   unsigned long  sqharm[4];<br>   unsigned long  *sqharc[4];<br>   unsigned short  sqadto[4];<br>   unsigned short  sqtdso[4];<br>} sqlstm &#x3D; {12,4};</p>
<p>&#x2F;* SQLLIB Prototypes *&#x2F;<br>extern sqlcxt ( void **, unsigned int *,<br>                   struct sqlexd *, struct sqlcxp * );<br>extern sqlcx2t( void **, unsigned int *,<br>                   struct sqlexd *, struct sqlcxp * );<br>extern sqlbuft( void **, char * );<br>extern sqlgs2t( void **, char * );<br>extern sqlorat( void **, unsigned int *, void * );</p>
<p>&#x2F;* Forms Interface *&#x2F;<br>static int IAPSUCC &#x3D; 0;<br>static int IAPFAIL &#x3D; 1403;<br>static int IAPFTL  &#x3D; 535;<br>extern void sqliem( unsigned char *, signed int * );</p>
<p>typedef struct { unsigned short len; unsigned char arr[1]; } VARCHAR;<br>typedef struct { unsigned short len; unsigned char arr[1]; } varchar;</p>
<p>&#x2F;* CUD (Compilation Unit Data) Array *&#x2F;<br>static short sqlcud0[] &#x3D;<br>{12,4130,1,0,0,<br>5,0,0,0,0,0,27,13,0,0,4,4,0,1,0,1,97,0,0,1,10,0,0,1,10,0,0,1,10,0,0,<br>36,0,0,2,0,0,30,22,0,0,0,0,0,1,0,<br>};</p>
<p>#include &lt;stdio.h&gt;<br>#include “sqlca.h”</p>
<p>&#x2F;* EXEC SQL BEGIN DECLARE SECTION; *&#x2F; </p>
<p>char* serversid &#x3D; “scott&#x2F;tiger@orcl”;&#x2F;&#x2F; 定义宿主变量<br>&#x2F;* EXEC SQL END DECLARE SECTION; *&#x2F; </p>
<p>int main(int argc, char* argv[])<br>{<br>int ret &#x3D; 0;<br>printf(“serversid: %s\n”, serversid);&#x2F;&#x2F; 打印一下服务器的连接地址字符串</p>
<p>&#x2F;* EXEC SQL CONNECT :serversid; *&#x2F; </p>
<p>{<br> struct sqlexd sqlstm;<br> sqlstm.sqlvsn &#x3D; 12;<br> sqlstm.arrsiz &#x3D; 4;<br> sqlstm.sqladtp &#x3D; &sqladt;<br> sqlstm.sqltdsp &#x3D; &sqltds;<br> sqlstm.iters &#x3D; (unsigned int  )10;<br> sqlstm.offset &#x3D; (unsigned int  )5;<br> sqlstm.cud &#x3D; sqlcud0;<br> sqlstm.sqlest &#x3D; (unsigned char  *)&sqlca;<br> sqlstm.sqlety &#x3D; (unsigned short)4352;<br> sqlstm.occurs &#x3D; (unsigned int  )0;<br> sqlstm.sqhstv[0] &#x3D; (unsigned char  *)serversid;<br> sqlstm.sqhstl[0] &#x3D; (unsigned long )0;<br> sqlstm.sqhsts[0] &#x3D; (         int  )0;<br> sqlstm.sqindv[0] &#x3D; (         short *)0;<br> sqlstm.sqinds[0] &#x3D; (         int  )0;<br> sqlstm.sqharm[0] &#x3D; (unsigned long )0;<br> sqlstm.sqadto[0] &#x3D; (unsigned short )0;<br> sqlstm.sqtdso[0] &#x3D; (unsigned short )0;<br> sqlstm.sqphsv &#x3D; sqlstm.sqhstv;<br> sqlstm.sqphsl &#x3D; sqlstm.sqhstl;<br> sqlstm.sqphss &#x3D; sqlstm.sqhsts;<br> sqlstm.sqpind &#x3D; sqlstm.sqindv;<br> sqlstm.sqpins &#x3D; sqlstm.sqinds;<br> sqlstm.sqparm &#x3D; sqlstm.sqharm;<br> sqlstm.sqparc &#x3D; sqlstm.sqharc;<br> sqlstm.sqpadto &#x3D; sqlstm.sqadto;<br> sqlstm.sqptdso &#x3D; sqlstm.sqtdso;<br> sqlstm.sqlcmax &#x3D; (unsigned int )100;<br> sqlstm.sqlcmin &#x3D; (unsigned int )2;<br> sqlstm.sqlcincr &#x3D; (unsigned int )1;<br> sqlstm.sqlctimeout &#x3D; (unsigned int )0;<br> sqlstm.sqlcnowait &#x3D; (unsigned int )0;<br> sqlcxt((void **)0, &amp;sqlctx, &amp;sqlstm, &amp;sqlfpn);<br>}</p>
<p>&#x2F;&#x2F; 连接服务器<br>if (sqlca.sqlcode !&#x3D; 0)&#x2F;&#x2F; 容错处理，后面会有更详细的文章介绍<br>{<br>ret &#x3D; sqlca.sqlcode;<br>printf(“connect oracle error… code &#x3D; %d\n”, ret);<br>return ret;<br>}</p>
<p>printf(“connect oracle success…\n”);<br>&#x2F;* EXEC SQL COMMIT RELEASE; *&#x2F; </p>
<p>{<br> struct sqlexd sqlstm;<br> sqlstm.sqlvsn &#x3D; 12;<br> sqlstm.arrsiz &#x3D; 4;<br> sqlstm.sqladtp &#x3D; &sqladt;<br> sqlstm.sqltdsp &#x3D; &sqltds;<br> sqlstm.iters &#x3D; (unsigned int  )1;<br> sqlstm.offset &#x3D; (unsigned int  )36;<br> sqlstm.cud &#x3D; sqlcud0;<br> sqlstm.sqlest &#x3D; (unsigned char  *)&sqlca;<br> sqlstm.sqlety &#x3D; (unsigned short)4352;<br> sqlstm.occurs &#x3D; (unsigned int  )0;<br> sqlcxt((void **)0, &amp;sqlctx, &amp;sqlstm, &amp;sqlfpn);<br>}</p>
<p>&#x2F;&#x2F; 提交(commit)并关闭(release)连接</p>
<p>return 0;<br>}</p>
<p>这是由 proc 预处理过后的 .c 文件，只不过是将我们之前编写的 pc 文件中的一些 EXE SQL … 等关键字替换成了真正的 c 语言执行语句。最后我们需要使用 gcc 来编译它。如果你直接编译的话，会收到如下报错：</p>
<p>[oracle@localhost 0723]$ gcc hello.c -o hello<br>&#x2F;tmp&#x2F;cchZbCeQ.o: In function `main’:<br>hello.c:(.text+0x86): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x1ed): undefined reference to `sqlcxt’<br>hello.c:(.text+0x1f2): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x200): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x27f): undefined reference to `ECPGget_sqlca’<br>hello.c:(.text+0x2b7): undefined reference to `sqlcxt’</p>
<p>这提示的意思是找不到动态库，所以我们需要手动指定动态库和头文件所在路径。正确的编译方法如下：</p>
<p>gcc hello.c -o hello -I $ORACLE_HOME&#x2F;precomp&#x2F;public -L $ORACLE_HOME&#x2F;lib -l clntsh</p>
<p>编译完成后运行程序，如果提示连接成功，那么证明你的程序就可以正常连接 oracle 服务器了：</p>
<p>[oracle@localhost 0723]$ .&#x2F;hello<br>serversid: scott&#x2F;tiger@orcl<br>connect oracle success…</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/Database/" title="Database">Database </a><a class="tag" href="/tags/oracle/" title="oracle">oracle </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2015/07/24/2015/2015-07-24_150324-842/,Dylan's blog,oracle proc 编程基础及最小化案例,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2015/07/24/2015/2015-07-24_161147-846/" title="proc 编程执行 insert、delete、update语句">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2015/07/24/2015/2015-07-24_114939-840/" title="oracle 索引">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>