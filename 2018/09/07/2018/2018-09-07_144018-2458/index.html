<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Qt 用画笔对图片实现马赛克效果 | Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Qt 用画笔对图片实现马赛克效果</h1>
    </header>

    <section>
      <p>最近接了一个用 Qt 做跨平台截图工具的任务，主要功能有截图、绘制图案、马赛克、毛玻璃、文字能效果，其中马赛克功能时参考网上的文献并自己研究制作出来的，这里特意给大家分享一下。有需要的朋友可以作为借鉴。</p>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先要开始实现之前，我们首先要来说一下我自己实现马赛克功能的原理。</p>
<ol>
<li>为了可以执行撤销操作，我们不能直接对图片进行修改。将图片附加到窗口上以后，需要在窗口上覆盖一层透明的窗口，在这个窗口使用画笔等工具来绘制马赛克，覆盖后面的图片来实现一个视觉效果，最终保存的时候将图片和透明窗口上绘制的数据合并得到一个绘制了马赛克效果的图片。</li>
<li>对窗口进行区块划分，比如当我们想让每个马赛克的块大小是 10px，那么我们以图片左上角为 0,0 点，给图片划分成一块一块 10px*10px 的小块。</li>
<li>当鼠标点击透明窗口的某个区域时要到实际后面图片的响应坐标取这个坐标对应像素的颜色值（QColor），如果条件允许可以将这个坐标周围的色值也都取出来做一个颜色混合得到平均的颜色色彩。</li>
<li>计算当前坐标对应的 10px_10px 小块的起始点坐标，然后根据已经取出来的颜色绘制一个 10px_10px 像素的方块。</li>
<li>鼠标移动过程中时时计算坐标，如果当前鼠标所在坐标已经绘制了一个图形那么不再绘制，如果没有绘制则重复 3、4 步。</li>
</ol>
<p>大体步骤就是这样的，接下来我们来拆分每一个步骤的实现方式。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p>这个透明窗口派生于 QWidget 类，在构造函数中设置窗口为透明的，这样在我们将绘制的马赛克和图片混合的时候就不会有窗口背景色了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 让窗口背景透明，在获取窗口绘制的数据时不显示背景色</span><br><span class="line">setAttribute(Qt::WA_TranslucentBackground, true);</span><br></pre></td></tr></table></figure>

<p>对窗口划分区域并根据鼠标得出马赛克绘制方块。在绘制前你要监听鼠标在窗口上按下、弹起、移动等消息，在鼠标按下前，我们要先初始化一个 image 对象来提供我们获取颜色，并根据图片大小初始化一个坐标数组，比如我们有一个 100*100 的图片，想让马赛克的大小是 10 像素，那么我们就要将这个图片宽和高都划分为 10 个 10 像素的小方块。记录下所有图片的像素坐标点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 将截取的未知转为 iamge 对象，用来获取坐标像素的颜色</span><br><span class="line">image_ = originPainting_-&gt;toImage();</span><br><span class="line">// 初始化每个像素点的坐标位置，鼠标移动过程中记录坐标并通过数组下标</span><br><span class="line">// 直接访问到数据查看某个区块是否已经被绘制上了马赛克。</span><br><span class="line">pointArray.reset(new QVector&lt;QVector&lt;bool&gt;&gt;);</span><br><span class="line">pointArray-&gt;resize(parentWidget()-&gt;width());</span><br><span class="line">for (int i = 0; i &lt; parentWidget()-&gt;width(); i++) &#123;</span><br><span class="line">    // 高度像素</span><br><span class="line">    (*pointArray)[i].resize(parentWidget()-&gt;height());</span><br><span class="line">&#125;</span><br><span class="line">for (int i = 0; i &lt; parentWidget()-&gt;width(); i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; parentWidget()-&gt;height(); j++) &#123;</span><br><span class="line">        (*pointArray)[i][j] = false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在按下的时候根据背景图像取像素的点，计算并记录像素坐标点归属那一块我们划分出来的小方块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">int x = endPoint_.x() - endPoint_.x() % mosaicSize_;</span><br><span class="line">int y = endPoint_.y() - endPoint_.y() % mosaicSize_;</span><br><span class="line"></span><br><span class="line">if (x &lt; 0) x = 0;</span><br><span class="line">if (y &lt; 0) y = 0;</span><br><span class="line"></span><br><span class="line">// 防止越界崩溃</span><br><span class="line">if (x &gt; pointArray-&gt;size() - mosaicSize_ </span><br><span class="line">    y &gt; (*pointArray)[0].size() - mosaicSize_) &#123;</span><br><span class="line">    break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if ((*pointArray)[x][y] == false) &#123;</span><br><span class="line">    (*pointArray)[x][y] = true;</span><br><span class="line"></span><br><span class="line">    MosaicData mosaic;</span><br><span class="line"></span><br><span class="line">    // 为适配 retina 屏幕从全屏界面中取像素颜色</span><br><span class="line">    QColor color = image_.pixel(realX, realY);</span><br><span class="line"></span><br><span class="line">    QPen pen;</span><br><span class="line">    pen.setColor(color);</span><br><span class="line"></span><br><span class="line">    mosaic.color_ = color;</span><br><span class="line">    mosaic.pen_ = pen;</span><br><span class="line">    mosaic.point_ = &#123; x, y &#125;;</span><br><span class="line"></span><br><span class="line">    drawMosaic_.push_back(mosaic);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鼠标移动的时候同样走上面的流程，记录下鼠标移动的所有的坐标。此时在透明窗口的 paintEvent 中，你已经可以根据 drawMosaic_ 里面记录的坐标开始绘制一个一个 mosaicSize_ 大小的小方块了。最后在保存图片的时候，你可以先将透明窗口图片保存为一个 pixmap，然后将 pixmap 合并到图片中就可以了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">QRect imageRect = CommonHelper::getRetinaRect(currentRect_);</span><br><span class="line"></span><br><span class="line">// 创建一副空背景图片</span><br><span class="line">QImage resultImg = QImage(imageRect.width(), imageRect.height(), QImage::Format_ARGB32);</span><br><span class="line">std::shared_ptr&lt;QPainter&gt; painter;</span><br><span class="line">painter.reset(new QPainter(&amp;resultImg));</span><br><span class="line"></span><br><span class="line">// 先绘制截图的内容</span><br><span class="line">painter-&gt;drawPixmap(QRect(0, 0, imageRect.width(), imageRect.height()), *originPainting_, imageRect);</span><br><span class="line"></span><br><span class="line">// 再绘制图形数据</span><br><span class="line">for (auto window : drawItemList_) &#123;</span><br><span class="line">    // 跳过空文本窗体</span><br><span class="line">    if (window-&gt;getDrawModel() == DrawUnit::MODEL::Text &amp;&amp; window-&gt;getDrawText().size() == 0) &#123;</span><br><span class="line">        continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取窗口数据到 pixmap 中</span><br><span class="line">    QPixmap pixmap = window-&gt;grab();</span><br><span class="line">    // 获取窗口实际大小</span><br><span class="line">    QRect windowRect = window-&gt;rect();</span><br><span class="line">    // retina 兼容</span><br><span class="line">    QRect windowImageRect = CommonHelper::getRetinaRect(windowRect);</span><br><span class="line"></span><br><span class="line">    painter-&gt;drawPixmap(QRect(currentRect_.width() - windowRect.width(), currentRect_.height() - windowRect.height(),</span><br><span class="line">        windowImageRect.width(), windowImageRect.height()), pixmap, windowImageRect);</span><br><span class="line"></span><br><span class="line">    window-&gt;close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return resultImg;</span><br></pre></td></tr></table></figure>

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><a href="/images/2018/09/2018-09-07-14-39-41.png"><img src="/images/2018/09/2018-09-07-14-39-41.png"></a></p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2018-09-07T14:40:18.000Z" itemprop="datePublished">
              2018-09-07
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Qt/">Qt</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>