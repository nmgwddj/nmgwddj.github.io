<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>Dylan's blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_155324-239/">函数模版与类模版</a></h3></div><div class="post-content"><p>模版是泛型编程中一种重要的手段，泛型编程意思是让多种数据类型的数据都可以在一个代码段算法中使用。泛型的代表作就是STL。其中模版则是让数据类型参数化，让调用者在使用的时候，多传递一个操作数据的类型便可以调用一份“参数个数相同而类型不同，且函数体相同”的代码段，这个代码段可以让多种数据类型都可以计算出正确的结果。我...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/模版/" title="模版">模版 </a><a class="tag" href="/tags/类/" title="类">类 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_155116-229/">“虚函数表”推演及多态的原理</a></h3></div><div class="post-content"><p>C++ 的多态性据前辈们所说，是非常难以理解的一部分内容，虽然他实现很简单，但是套用到各种设计模式后，你会非常难以理解，但无论怎样，笔者始终认为，如果了解了内部的实现原理，实际就不会那么难了。本文将介绍虚函数表的相关内容，阐述了它与多态之间难以割舍的关系。

默认情况下，一个没有任何成员变量的类，大小是 1 个字...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_154348-225/">抽象类纯虚函数与虚析构</a></h3></div><div class="post-content"><p>纯虚函数，一般是在设计一个基类时使用的，它将接口函数设置为纯虚函数后，只提供子类去继承并实现，以形成多态，除此以外不提供任何其他功能，我们称这种类为抽象类(abstract)。

【纯虚函数的声明语法】
virtual 函数声明 &#x3D; 0;
【纯虚函数的特征】 1、只有声明，没有实现代码。 2、含有纯虚函...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/24/2015/2015-05-24_230539-222/">多态形成的三要素</a></h3></div><div class="post-content"><p>上一篇文章中，我们看到了简单的赋值兼容模型，将子类赋值给父类对象时，调用共有的同名接口时，调用的依然还是父类的成员函数。在 C++ 中，有一个总要的概念，那就是多态。通过父类提供一些虚函数，让子类继承下去并实现为另外的功能，然后将子类对象的地址赋值给父类的对象指针。这样再次使用父类的指针调用共有同名接口时，你会发...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/24/2015/2015-05-24_225759-218/">子类赋值父类的赋值兼容</a></h3></div><div class="post-content"><p>C++ 中，类型的匹配检测是非常严格的，但是你会发现一个现象，如果一个类继承了另外一个类，把子类的对象赋值给父类的时候，系统不但不提示错误，而且程序还能顺利的编译通过并运行。这其实就是 C++ 内部提供的赋值兼容的过程，但是要注意，如果子类数据成员比父类多，则会出现数据截断。具体表现形式如下图：

 示例代码如下...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/24/2015/2015-05-24_194301-211/">多继承三角和钻石问题（虚继承）</a></h3></div><div class="post-content"><p>上一篇文章我们简单介绍了一下多继承的语法，但是我们遇到了一个问题，那就是如果多个父类具有相同名称的成员变量或成员方法，子类在调用的时候就会出现二义性问题，子类不知道选择哪一个父类的变量或方法，我们称之为三角问题。如下所示：

 所以在编译的时候程序就无法通过了。其实解决这个问题有很多办法，先说一个最简单的办法就是...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/24/2015/2015-05-24_191438-207/">多继承案例及常见问题</a></h3></div><div class="post-content"><p>多继承，是希望一个子类可以继承多个父类的资源，使自己的功能更加强大，有一个床类、一个沙发类，我们希望将两个类的功能整合到一起，成为一个“沙发床”的类，即可以睡觉、又可以做。这就是多继承的应用。当然我们说的有一些抽象，下面代码演示了多继承的案例。

#include 
using namespace std;
cl...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-24</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/23/2015/2015-05-23_230555-205/">派生类的实始化、初始化顺序</a></h3></div><div class="post-content"><p>1、先实始化父类成员，调用父类的构造函数，有多个基类的从左向右按声明顺序实始化。 2、内嵌对象实始化，内嵌对像的构造器。如果父类或是内嵌对象，有无参构造器的话，可以不用显示的调用。如无无参且未调用则会报错。 3、派生类的构造器。

构造器的调用过程是，基类-&gt;成员-&gt;子类，而且析构器我们基本上不用去管...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-23</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/23/2015/2015-05-23_225139-203/">继承权限及关系简单阐述</a></h3></div><div class="post-content"><p>类具有三种成员属性，一种是public、一种是protected、一种是private。这三种在派生的类中也有不同的访问权限，当然不单单只看父类的成员属性，还要看派生类以什么方式继承父类，如下代码所示：

#include 
using namespace std;
class Base&#x2F;&#x2F; ...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-23</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/22/2015/2015-05-22_215618-201/">shadow、overload、override</a></h3></div><div class="post-content"><p>shadow（阴影）、overload（重载）、override（覆写），这三个概念一直有人非常混淆，很幸运，经过老师的悉心教导，我总结了一下三个概念的不同之处。 shadow：发生在父子之间，需要函数名相同即可构成 shadow （阴影），构成 shadow 后可通过域运算符来访问对应类中的函数。
#inclu...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-22</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/重载/" title="重载">重载 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/page/33/">上一页</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/35/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>