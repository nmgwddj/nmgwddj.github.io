<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author"><title>Dylan's blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Archivo</a></li><li><a href="/links">Enlaces</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/28/2015/2015-05-28_191233-307/">循环链表的增删改查</a></h3></div><div class="post-content"><p>循环链表与单向链表十分相似，两者唯一不同之处就是，循环链表的尾节点的next属性指向了链表的首节点（非头节点，头节点是没有数据的，头节点的下一个有数据的节点我们称为首节点）。他的表现形式有常见的两种，如下图：

 一种是上面我们说的，而另外一种，则是将尾节点的next指向了头节点，这种做法不是方便，所以用的比较少...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/DataStruct/" title="DataStruct">DataStruct </a><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/tags/指针/" title="指针">指针 </a><a class="tag" href="/tags/链表/" title="链表">链表 </a><a class="tag" href="/tags/查找/" title="查找">查找 </a><a class="tag" href="/tags/类型转换/" title="类型转换">类型转换 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/28/2015/2015-05-28_174813-302/">线性表链式存储</a></h3></div><div class="post-content"><p>上文中我们介绍了线性表顺序储存的方式，并给大家画了一幅比较详细的图（虽然看着比较凌乱），本文介绍的是数据储存的另外一种方式“链式储存”，这相当于我们之前提到过的单向链表，但是，本文与上一篇文章一样，都将数据的储存和算法进行了分离。这才是我们真正应该晋级了解的东西，如果只是一个单向链表，不足以我们耗费这么多精力。
...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-28</span><i class="fa fa-tag"></i><a class="tag" href="/categories/DataStruct/" title="DataStruct">DataStruct </a><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/tags/指针/" title="指针">指针 </a><a class="tag" href="/tags/进程空间/" title="进程空间">进程空间 </a><a class="tag" href="/tags/链表/" title="链表">链表 </a><a class="tag" href="/tags/查找/" title="查找">查找 </a><a class="tag" href="/tags/类型转换/" title="类型转换">类型转换 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/26/2015/2015-05-26_223115-258/">线性表顺序储存</a></h3></div><div class="post-content"><p>线性表，是一个或多个数据元素的集合，数据之间是连续的一段内存。线性表的特性如下。

数据元素之间是有顺序的
数据元素个数是有限的
数据元素的类型必须相同
以下代码中包含了线性表的增删改查的实现，并且实现了数据结构和算法的分离，使任何数据类型，都可以通过我们编写的线性表类来储存。中间发生的变化在代码后面一幅图中做了...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-26</span><i class="fa fa-tag"></i><a class="tag" href="/categories/DataStruct/" title="DataStruct">DataStruct </a><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/tags/数组/" title="数组">数组 </a><a class="tag" href="/tags/链表/" title="链表">链表 </a><a class="tag" href="/tags/查找/" title="查找">查找 </a><a class="tag" href="/tags/类型转换/" title="类型转换">类型转换 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_162110-253/">cocos2dx 入口分析</a></h3></div><div class="post-content"><p>为了理解多态的进一步应用，老师带着我们简单分析了一下cocos2dx的入口，深刻的体会到了虚函数和类静态成员变量的作用。以此给大家分享一下这个过程。

打开cocos2dx的main.cpp文件，我们可以看到如下代码： 
#include “main.h”#include “AppDelegate.h”#incl...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_161439-182/">自实现 MyString 类</a></h3></div><div class="post-content"><p>自实现 myString 类主要目的是剖析系统内部的 string 类的一些实现方法以及加强对类封装、运算符重载等特性的掌握。其中包含了几项非常重要的功能实现。

使用构造器创建对象。
拷贝构造器创建对象。
赋值运算符重载构造对象。
[]运算符重载构造对象数组。
=&#x3D;运算符重载判断对象是否相等。
+运算...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/运算符重载/" title="运算符重载">运算符重载 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_161101-248/">STL 常用方法集合</a></h3></div><div class="post-content"><p>我本想将 STL 中各种容器的实现方法和作用全部写一遍，然后每种容器都发一篇文章，但后来发现这样做的意义不大，在 MSDN 或其他一些帮助文档中，他们比我写的要详细，其实我只需要记住每种容器的常用方法，和在什么场合选择合适的容器。下面这张表是我这里的一些常用方法集合。备用参考。


</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/categories/Algorithm/" title="Algorithm">Algorithm </a><a class="tag" href="/tags/字符串/" title="字符串">字符串 </a><a class="tag" href="/tags/数组/" title="数组">数组 </a><a class="tag" href="/tags/链表/" title="链表">链表 </a><a class="tag" href="/tags/排序/" title="排序">排序 </a><a class="tag" href="/tags/查找/" title="查找">查找 </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/模版/" title="模版">模版 </a><a class="tag" href="/tags/STL/" title="STL">STL </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_160642-246/">iomanip 流输入输出格式控制</a></h3></div><div class="post-content"><p>在 C 中，我们使用 printf 输出内容时，可以使用多种格式控制方法，比如 %x %d %f %p 等等，但在 C++ 的io流输入输出的类中，我们找不到这些方法也不知道如何实现这些功能了。本文就介绍一些 C++ 中，io流输入输出格式控制的函数。

#include #include  using name...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_160322-242/">C++ 读写文本文件和二进制文件</a></h3></div><div class="post-content"><p>在 C 中，我们通过 FILE 结构体生成的指向 FILE 结构体的指针来操作文件。其提供了诸如 fgetc、fgets、feof等等函数，在 C++ 中重新封装了操作文件的方法，其实现在 iostream 派生的 fstream 中，实际内部实现基本原理与 C 相同。下面就分别介绍下操作文本文件和二进制文件的方...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_155324-239/">函数模版与类模版</a></h3></div><div class="post-content"><p>模版是泛型编程中一种重要的手段，泛型编程意思是让多种数据类型的数据都可以在一个代码段算法中使用。泛型的代表作就是STL。其中模版则是让数据类型参数化，让调用者在使用的时候，多传递一个操作数据的类型便可以调用一份“参数个数相同而类型不同，且函数体相同”的代码段，这个代码段可以让多种数据类型都可以计算出正确的结果。我...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/模版/" title="模版">模版 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/05/25/2015/2015-05-25_155116-229/">“虚函数表”推演及多态的原理</a></h3></div><div class="post-content"><p>C++ 的多态性据前辈们所说，是非常难以理解的一部分内容，虽然他实现很简单，但是套用到各种设计模式后，你会非常难以理解，但无论怎样，笔者始终认为，如果了解了内部的实现原理，实际就不会那么难了。本文将介绍虚函数表的相关内容，阐述了它与多态之间难以割舍的关系。

默认情况下，一个没有任何成员变量的类，大小是 1 个字...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-05-25</span><i class="fa fa-tag"></i><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/tags/类/" title="类">类 </a><a class="tag" href="/tags/多态/" title="多态">多态 </a><a class="tag" href="/tags/继承与派生/" title="继承与派生">继承与派生 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/page/32/">Anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/34/">Siguiente</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>