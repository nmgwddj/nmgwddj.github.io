<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>Dylan's blog</title><meta name="description" content="A Blog Powered By Hexo"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a class="current" href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)" style="display:none;"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_173828-737/">多线程互斥锁解决哲学家就餐问题</a></h3></div><div class="post-content"><p>哲学家就餐问题是一个了解和练习线程间同步的非常好的小例子，题为 5 个哲学家（线程）围成一桌就餐，但是只有 5 只筷子（锁），一个人想要吃饭就必须要拥有左侧的筷子（锁1）和右侧的筷子（锁2）才能吃饭。每一个哲学家刚进桌前都持有了自己左侧的筷子，这样所有人只有一只筷子都无法就餐，所以就要想办法去拿右侧的筷子，而因为...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_173142-735/">信号量实现的生产者消费者模型</a></h3></div><div class="post-content"><p>信号量实现生产者消费者模型，可以无需互斥量（mutex）协助就能实现。实现方法是声明两个信号量变量，两个信号量分别代表可生产产品的数量和已经生产的产品数量，然后在线程函数中维护这两个信号量变量实现生产者消费者模型。


【代码实现】#include &lt;stdio.h&gt;#include &lt;pthr...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_172622-733/">使用条件变量实现生产者消费者模型</a></h3></div><div class="post-content"><p>生产者消费者模型是多线程案例中经常用到的一种模型，有专门的线程在负责生产产品（这个产品指代程序所需的数据、文件等等），有专门的线程在负责取出生产出来的产品用以提供程序使用（消费）。因为生产和消费在程序中是不定时间的，我们也无法确定什么时候需要生产产品，什么时候需要消费产品。所以就有了使用条件变量实现的解决方案。
...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_171537-731/">互斥量操作原语</a></h3></div><div class="post-content"><p>保证在某一时刻只有一个线程能访问数据的简便办法。在任意时刻只允许一个线程对共享资源进行访问。如果有多个线程试图同时访问临界区，那么 在有一个线程进入后其他所有试图访问此临界区的线程将被挂起，并一直持续到进入临界区的线程离开。临界区在被释放后，其他线程可以继续抢占，并以此达到用原子方式操作共享资源的目的。临界区的选...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_170518-724/">线程属性设置</a></h3></div><div class="post-content"><p>本文将通过一个创建n个线程的案例来展示一下线程属性的设定及使用，通常情况下，系统对于线程的创建是没有限制的，但是每一个线程都是需要一个栈空间的，每个栈空间大小也都是固定的，可通过系统命令 ulimit -a 来查看，如果线程栈空间的总数超过了一个进程可使用的虚拟内存用户空间，那么就无法再继续创建线程了。我们只是做...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_164417-720/">安装线程相关 man page</a></h3></div><div class="post-content"><p>默认情况下 ubuntu 系统中是没有线程相关的 man page，需要我们手动自己下载一次。使用如下命令可以下载 pthread 相关的 man page 文档：


sudo apt-get install manpages-posix manpages-posix-dev

查看系统当前 pthread 库...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_163644-716/">守护进程编写标准和实现</a></h3></div><div class="post-content"><p>Daemon(精灵)进程,是Linux中的后台服务进程,生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。类似于Windows下的服务程序。通常的 linux 程序在我们通过终端运行挂起后，再关闭终端，这些程序的运行进程也会随着终端一起关闭，这是因为他们属于同一会话。如果不想程...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/05/2015/2015-07-05_115712-705/">引入信号后的几种陷阱讲解</a></h3></div><div class="post-content"><p>程序在引入信号机制后会变的非常多元化，程序在某些情况下难以理解并且会出现一些非常奇特的问题，但这些问题经过总结无非是因为使用了不可重入函数、信号引起的时序竞态、信号处理函数与主程序的异步io过程中出现的问题。要避免这些问题，我们要先来复现和分析这些情况是如何出现的，才能针对性的去解决这些问题。


【可重入&#x...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-05</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/信号/" title="信号">信号 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/02/2015/2015-07-02_190900-701/">信号捕捉（拦截）</a></h3></div><div class="post-content"><p>在一个程序收到某些信号后，程序都会自动去执行默认的操作，但大多的操作都会导致程序异常退出，除了前文我们介绍的阻塞信号以外，我们还可以对信号进行捕获（拦截）处理，让被捕获的信号去执行我们已经编写好的函数中，这样可以帮我们处理太多的问题。


C语言库函数中，提供了一个信号捕获函数，如下：
typedef void ...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-02</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a><a class="tag" href="/tags/信号/" title="信号">信号 </a></div></div></div></div><div class="post animated fadeInDown"><div class="post-title"><h3><a href="/2015/07/01/2015/2015-07-01_232142-695/">阻塞信号</a></h3></div><div class="post-content"><p>所谓阻塞，就是屏蔽掉某信号，让程序在收到某信号以后不做任何事情，包括默认动作也不执行。要实现这个需求，我们首先得了解一下系统对于每一个进程的信号是如何投递的，这个信号的走向流程是怎么样的，才能针对性的下手实现这个需求。


在每一个进程的 PCB 中，分别维护着两个信号集列表，这两个信号集列表分别叫“未决信号集”...</p></div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-07-01</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/platform/Linux-Unix/" title="Linux/Unix">Linux/Unix </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/tags/进程-线程/" title="进程/线程">进程/线程 </a><a class="tag" href="/tags/信号/" title="信号">信号 </a></div></div></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/page/25/">上一页</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/page/27/">下一页</a></li></ul></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>