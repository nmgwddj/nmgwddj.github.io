---
title: 守护进程编写标准和实现
tags:
  - 进程/线程
id: '716'
categories:
  - - platform
    - Linux/Unix
  - - Platform
date: 2015-07-05 16:36:44
---

Daemon(精灵)进程,是Linux中的后台服务进程,生存期较长的进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。类似于Windows下的服务程序。通常的 linux 程序在我们通过终端运行挂起后，再关闭终端，这些程序的运行进程也会随着终端一起关闭，这是因为他们属于同一**会话**。如果不想程序随着终端关闭而关闭，那么就要让程序脱离终端的会话组，那么就需要使用到setsid()函数了。一个正确的守护进程编写过程如下：
<!-- more -->
* * *

**1\. 创建子进程，父进程退出** 所有工作在子进程中进行 形式上脱离了控制终端 **2\. 在子进程中创建新会话** setsid()函数 使子进程完全独立出来，脱离控制 **3\. 改变当前目录为根目录** chdir()函数 防止占用可卸载的文件系统 也可以换成其它路径 **4\. 重设文件权限掩码** umask()函数 防止继承的文件创建屏蔽字拒绝某些权限 增加守护进程灵活性 **5\. 关闭文件描述符** 继承的打开文件不会用到，浪费系统资源，无法卸载 **6\. 开始执行守护进程核心工作** **7\. 守护进程退出处理**

* * *

### 【代码实现】

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>

void daemonize(void)
{
pid\_t pid;
//创建子进程
if ((pid = fork()) < 0)
{
perror("fork");
exit(1);
}
// 父进程直接退出
else if (pid != 0)
{
exit(1);
}
// 子进程开始工作
// 设置会话ID，使其彻底脱落终端工作
setsid();

// 改变当前工作目录到主目录
if (chdir("/") < 0)
{
perror("chdir");
exit(1);
}
// 设置掩码
umask(0);
// 重定向 0 1 2 文件描述符到 /dev/null
// 因为已经脱离终端，在操作没有意义
close(0);
open("/dev/null", O\_RDWR);
dup2(0, 1);
dup2(0, 2);
}

int main(int argc, char\* argv\[\])
{
daemonize();
while (1)
{
sleep(1);
// 此处执行守护进程的核心任务
}
return 0;
}

* * *

### 【效果图】

[![2015-07-05_162728](/images/2015/07/2015-07-05_162728.png)](/images/2015/07/2015-07-05_162728.png) 该程序运行后，即使马上退出终端，程序也不会随着终端的退出而退出了。