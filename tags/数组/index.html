<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <ul class="Index">
  
    <header class='PageTitle'>
        <h1>{ 数组 }</h1>
    </header>
  
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2016/03/30/2016/2016-03-30_125202-1548/">Windows 内核实现复制文件</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2016-03-30T12:52:02.000Z" itemprop="datePublished">
    2016-03-30
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%8C%87%E9%92%88/">指针</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/language/">language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/language/C-C/">C/C++</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/Language/">Language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/platform/">platform</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/Platform/">Platform</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/platform/Windows/">Windows</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>Windows 内核编程并没有提供像 Ring3 层的 CopyFile 这样的 API，看了看书中的例子自己写了一份 MyCopyFile，以后用来备用。</p>
        
          <div class="more-link">
            <a href="/2016/03/30/2016/2016-03-30_125202-1548/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2016/02/16/2016/2016-02-16_005417-1497/">数据全排列组合</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2016-02-16T00:54:17.000Z" itemprop="datePublished">
    2016-02-16
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E9%80%92%E5%BD%92/">递归</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%A8%A1%E7%89%88/">模版</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Algorithm/">Algorithm</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>所谓全排列就是将一个数据组合拆开重新排列，比如 abc，可重新排序为 acb、bac、bca、cab、cba，通过算法上实现一般就是递归或一个while循环来实现。最近复习算法方面的内容接触到的新的算法，记录一下思路。</p>
        
          <div class="more-link">
            <a href="/2016/02/16/2016/2016-02-16_005417-1497/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/11/08/2015/2015-11-08_132721-1105/">JavaScript 数组常用操作函数</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-11-08T13:27:21.000Z" itemprop="datePublished">
    2015-11-08
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/language/">language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/language/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>JavaScipt 数组的一些常用操作，高级语言这些优点就是好，给数组排序一个 sort 就搞定了，在 C 下要自己写算法。真的是大大节省了时间。</p>
<p>var arr &#x3D; new Array(“html”, “body”, “head”, “title”, “style”, “script”, “span”, “title”);<br>&#x2F;&#x2F; 在尾部插入元素<br>arr.push(“ul”);<br>console.log(“push”, arr);<br>&#x2F;&#x2F; 弹出尾部最后一个元素<br>arr.pop();<br>console.log(“pop”, arr);<br>&#x2F;&#x2F; 在首部插入一个元素<br>arr.unshift(“dt”);<br>console.log(“unshift”, arr);<br>&#x2F;&#x2F; 弹出首部第一个元素<br>arr.shift();<br>console.log(“shift”, arr);<br>&#x2F;&#x2F; 按字典序（ASCII）排序<br>arr.sort();<br>console.log(“sort”, arr);<br>&#x2F;&#x2F; 翻转数组<br>arr.reverse(arr)<br>console.log(“reverse”, arr);<br>&#x2F;&#x2F; 返回数组指定位置的几个元素<br>console.log(“slice”, arr.slice(2, 4));<br>&#x2F;&#x2F; 在数组中首次出现的位置<br>console.log(“indexOf”, arr.indexOf(“title”));<br>&#x2F;&#x2F; 在数组中最后一次出现的位置<br>console.log(“lastindexOf”, arr.lastIndexOf(“title”));</p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/11/04/2015/2015-11-04_201415-1102/">JavaScript for 和 for in 遍历的区别</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-11-04T20:14:15.000Z" itemprop="datePublished">
    2015-11-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/language/">language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/language/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>一个数组，如果有个20个元素，但有效元素只有不到5个，剩下的全部是 undefined，此时使用 for 遍历的话，所有元素都会被遍历出来，包括 undefined，但如果使用 for in 则不会出现这种情况，for in 只会遍历出有效的元素，并且与 for 不同的时，for in 可以遍历出数组的成员属性。我们看如下代码和打印的结果。</p>
        
          <div class="more-link">
            <a href="/2015/11/04/2015/2015-11-04_201415-1102/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/11/04/2015/2015-11-04_192743-1093/">JavaScript 三种声明数组的方式</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-11-04T19:27:43.000Z" itemprop="datePublished">
    2015-11-04
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/language/">language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/language/JavaScript/">JavaScript</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>开始恶补 JavaScript 的基础知识，数组篇。</p>
<p>&#x2F;&#x2F; 第一种<br>var color &#x3D; [“red”, “black”, “gold”, “pink”];<br>console.log(color);<br>&#x2F;&#x2F; 第二种<br>var animal &#x3D; new Array(“dog”, “pic”, “cat”);<br>console.log(animal);<br>&#x2F;&#x2F; 第三种<br>var city &#x3D; Array();<br>city[0] &#x3D; “北京”;<br>city[1] &#x3D; “上海”;<br>city[2] &#x3D; “杭州”;<br>city[“henan”] &#x3D; “郑州”; &#x2F;&#x2F; 给 city 对象声明一个成员属性 henan，并非数组元素<br>console.log(city);<br>console.log(city[1]);<br>console.log(city.henan);<br>console.log(city[“河南”]);</p>
<p>注意最后的 city[“henan”] &#x3D; “郑州”，并不是给数组添加一个元素，而是给 city 这个数组对象添加了一个成员属性。在计算数组长度的时候，它不被算在内。 <a href="/images/2015/11/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2015-11-04-%E4%B8%8B%E5%8D%8819.32.42-%E4%B8%8B%E5%8D%88.png"><img src="/images/2015/11/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7-2015-11-04-%E4%B8%8B%E5%8D%8819.32.42-%E4%B8%8B%E5%8D%88-1024x384.png" alt="屏幕快照 2015-11-04 下午19.32.42 下午"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/06/01/2015/2015-06-01_224622-381/">二叉树的细分及五大性质</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-06-01T22:46:22.000Z" itemprop="datePublished">
    2015-06-01
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/DataStruct/">DataStruct</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>二叉树细分了两种类型的二叉树，一种叫做“满二叉树”，就是每一层都挂满了节点，没有空位。另一种叫做“完全二叉树”，完全二叉树假设有n层，那么n-1层和满二叉树是一样的，但是<strong>第n层最后一个节点前边都挂满了节点。这是它们两个概念的唯一具体区别。</strong>表示图如下：</p>
<p>【满二叉树】</p>
<p><a href="/images/2015/06/2015-06-01_223256.png"><img src="/images/2015/06/2015-06-01_223256.png" alt="2015-06-01_223256"></a></p>
<p>【完全二叉树】</p>
<p><a href="/images/2015/06/2015-06-01_223801.png"><img src="/images/2015/06/2015-06-01_223801.png" alt="2015-06-01_223801"></a> 上面的树符合最后一个节点（F节点）前都挂满了节点的规则，所以它属于一个完全二叉树。下面重点来了，二叉树具有5大性质，如下介绍。</p>
<h3 id="【二叉树的五大性质】"><a href="#【二叉树的五大性质】" class="headerlink" title="【二叉树的五大性质】"></a>【二叉树的五大性质】</h3><ul>
<li><p><strong>性质1: 在二叉树的第i层上至多有2i-1个结点（i&gt;0）。</strong> 比如第3层，那么就是 23-1 &#x3D; 4，第3层最多有4个节点</p>
</li>
<li><p><strong>性质2: 深度为k的二叉树至多有2k-1个结点（k&gt;0）。</strong> 比如第3层，最多有 23 -1 &#x3D; 7 个节点</p>
</li>
<li><p><strong>性质3: 对于任何一棵二叉树，若2度的结点数有n2个，则叶子数（n0）必定为n2＋1 （即n0&#x3D;n2+1）</strong> 度为2的节点有3个（A B C），那么 n2 &#x3D; 3 叶子数 &#x3D; n2 + 1，那么就是 3 + 1 &#x3D; 4 个</p>
</li>
<li><p><strong>性质4: 具有n个结点的完全二叉树的深度必为log2n(向下取整)＋1</strong> log2n + 1 转换为公式是 2x &#x3D; n，此时 n 为 7 ，所以 x 约等于 2.几次方，向下取整后得 2 深度 &#x3D; x + 1，2 + 1 &#x3D; 3，所以深度结果就是3</p>
</li>
<li><p><strong>性质5: 对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i&#x2F;2（i＝1 时为根,除外）。</strong> 如下图：编号为3的节点是C，其左子节点的编号是2*3&#x3D;6就是F，右子节点的编号是2*3+1&#x3D;7就是G，双亲的编号是 3&#x2F;2&#x3D;1就是A</p>
</li>
</ul>
<p><a href="/images/2015/06/2015-06-01_224246.png"><img src="/images/2015/06/2015-06-01_224246.png" alt="2015-06-01_224246"></a> 最后我们做一下总结，讲了这么多，无非我们就是希望引出二叉树是有规则的，我们将二叉树存入一个数组后，是可以恢复回来的，不像多叉树那样无法恢复。根据第五条的性质，我们很轻松就可以在一个存放在数组中的二叉树数据恢复为一个二叉树模型。 而如果是一个非满二叉树怎么办呢？我们如何把非满二叉树存放到一个数组里面呢？其实思路非常简单，我们只需把哪些缺少一个子节点的节点给他填充一个空就可以了。如下图： <a href="/images/2015/06/2015-06-03_232545.png"><img src="/images/2015/06/2015-06-03_232545.png" alt="2015-06-03_232545"></a></p>

      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/06/01/2015/2015-06-01_193347-374/">多插树转为二叉树</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-06-01T19:33:47.000Z" itemprop="datePublished">
    2015-06-01
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/DataStruct/">DataStruct</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>在搞清楚多叉树转换为二叉树之前，我们有必要想清楚，为什么要这样转换？多叉树哪里有缺点需要我们转换为二叉树使用？我们来考虑一个问题：“如果我们将一个多叉树存放在一个数组中，然后删除了整个多叉树。我们能否通过这个仅有的数组恢复原来的多叉树呢？”</p>
        
          <div class="more-link">
            <a href="/2015/06/01/2015/2015-06-01_193347-374/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/05/31/2015/2015-05-31_212505-363/">队列(queue)的概念及常见应用</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-05-31T21:25:05.000Z" itemprop="datePublished">
    2015-05-31
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/DataStruct/">DataStruct</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>队列是一种先进先出的数据模型，它的应用场景比较常见，比如日常生活中我们打10086的电话需要排队时、吃饭排号时的小票、Windows GUI程序的消息队列等等都是基于队列实现的。先进入队列的也是先从队列出去的。他的模型如下：</p>
        
          <div class="more-link">
            <a href="/2015/05/31/2015/2015-05-31_212505-363/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/05/26/2015/2015-05-26_223115-258/">线性表顺序储存</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-05-26T22:31:15.000Z" itemprop="datePublished">
    2015-05-26
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%9F%A5%E6%89%BE/">查找</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">类型转换</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/Algorithm/">Algorithm</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/DataStruct/">DataStruct</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>线性表，是一个或多个数据元素的集合，数据之间是连续的一段内存。线性表的特性如下。</p>
<ol>
<li>数据元素之间是有顺序的</li>
<li>数据元素个数是有限的</li>
<li>数据元素的类型必须相同
        
          <div class="more-link">
            <a href="/2015/05/26/2015/2015-05-26_223115-258/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
    <li>
      <article class='ListView'>
    <header class="title">
      
        <h1>
          <a href="/2015/05/25/2015/2015-05-25_161101-248/">STL 常用方法集合</a>
        </h1>
      
      <div class='ListMeta'>
  <time datetime="2015-05-25T16:11:01.000Z" itemprop="datePublished">
    2015-05-25
  </time>
  
  | 
  <ul>
    
  <li class="meta-text">
  { <a href="/tags/%E6%95%B0%E7%BB%84/">数组</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%8E%92%E5%BA%8F/">排序</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%9F%A5%E6%89%BE/">查找</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E9%93%BE%E8%A1%A8/">链表</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/">字符串</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E7%B1%BB/">类</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/%E6%A8%A1%E7%89%88/">模版</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/STL/">STL</a> }
  </li>


  </ul>
  
  
  / 
  <ul>
    
  <li class="meta-text">
  { <a href="/categories/language/">language</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/language/C-C/">C/C++</a> }
  </li>

  <li class="meta-text">
  { <a href="/categories/Algorithm/">Algorithm</a> }
  </li>


  </ul>
  
</div>

    </header>
    <div>
      
        <p>我本想将 STL 中各种容器的实现方法和作用全部写一遍，然后每种容器都发一篇文章，但后来发现这样做的意义不大，在 MSDN 或其他一些帮助文档中，他们比我写的要详细，其实我只需要记住每种容器的常用方法，和在什么场合选择合适的容器。下面这张表是我这里的一些常用方法集合。备用参考。</p>
        
          <div class="more-link">
            <a href="/2015/05/25/2015/2015-05-25_161101-248/#more">Read On »</a>
          </div>
        
      
    </div>
</article>

    </li>
  
</ul>

  <section id="nav-wrapper">
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/tags/%E6%95%B0%E7%BB%84/page/2/">2</a><a class="extend next" rel="next" href="/tags/%E6%95%B0%E7%BB%84/page/2/">next »</a>
    </nav>
  </section>



            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>