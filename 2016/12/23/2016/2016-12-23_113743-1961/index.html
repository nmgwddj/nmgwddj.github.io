<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Dylan,2894220@qq.com"><title>微软 Credential Providers 详解二《关键函数》 · Dylan's blog</title><meta name="description" content="上一篇中我们介绍了凭据的加载和代码中函数的调用顺序，接下来我们就要了解一下一些关键函数在代码中起到什么作用了。了解清楚这些以后我们才能定制出我们自己需要功能。

CSampleProvider::SetUsageScenario这个函数非常重要，在凭据被加载起来以后，由微软调用，我们实现这个函数里面"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 7.1.1"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Dylan's blog</a></h3><div class="description"><p>To the pursuit of truth.</p></div></div></div><ul class="social-links"><li><a target="_blank" rel="noopener" href="http://github.com/nmgwddj"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a target="_blank" rel="noopener" href="https://www.caicai.me"> CaiCai </a><span>&</span><a target="_blank" rel="noopener" href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/favicon.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>微软 Credential Providers 详解二《关键函数》</a></h3></div><div class="post-content"><p>上一篇中我们介绍了凭据的加载和代码中函数的调用顺序，接下来我们就要了解一下一些关键函数在代码中起到什么作用了。了解清楚这些以后我们才能定制出我们自己需要功能。</p>
<span id="more"></span>
<h2 id="CSampleProvider-SetUsageScenario"><a href="#CSampleProvider-SetUsageScenario" class="headerlink" title="CSampleProvider::SetUsageScenario"></a>CSampleProvider::SetUsageScenario</h2><p>这个函数非常重要，在凭据被加载起来以后，由微软调用，我们实现这个函数里面的功能，微软调用时会给函数传递两个参数，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HRESULT CSampleProvider::SetUsageScenario(</span><br><span class="line">    __in CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,</span><br><span class="line">    __in DWORD dwFlags</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>其中 <code>dwFlags</code> 函数我们不需要关心，着重要关注的是 <code>cpus</code> 参数，这个参数标志了系统是锁屏、还是开机时登录而调用的凭据。如果是锁屏，那么 cpus 的值等于 <code>CPUS_UNLOCK_WORKSTATION</code>，而如果是开机登陆（或切换用户）则 cpus 的值等于 <code>CPUS_LOGON</code>。通过判断不同的登录类型，我们来给使用者显示不同的界面。而微软的例子中是将两中登录类型都同时创建了一个凭据，看如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">// SetUsageScenario is the provider&#x27;s cue that it&#x27;s going to be asked for tiles</span><br><span class="line">// in a subsequent call.</span><br><span class="line">HRESULT CSampleProvider::SetUsageScenario(</span><br><span class="line">    __in CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,</span><br><span class="line">    __in DWORD dwFlags</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(dwFlags);</span><br><span class="line">    HRESULT hr;</span><br><span class="line"></span><br><span class="line">    // Decide which scenarios to support here. Returning E_NOTIMPL simply tells the caller</span><br><span class="line">    // that we&#x27;re not designed for that scenario.</span><br><span class="line">    switch (cpus)</span><br><span class="line">    &#123;</span><br><span class="line">    case CPUS_LOGON:</span><br><span class="line">    case CPUS_UNLOCK_WORKSTATION:       </span><br><span class="line">        _cpus = cpus;</span><br><span class="line"></span><br><span class="line">        // Create and initialize our credential.</span><br><span class="line">        // A more advanced credprov might only enumerate tiles for the user whose owns the locked</span><br><span class="line">        // session, since those are the only creds that wil work</span><br><span class="line">        _pCredential = new CSampleCredential();</span><br><span class="line">        if (_pCredential != NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            hr = _pCredential-&gt;Initialize(_cpus, s_rgCredProvFieldDescriptors, s_rgFieldStatePairs);</span><br><span class="line">            if (FAILED(hr))</span><br><span class="line">            &#123;</span><br><span class="line">                _pCredential-&gt;Release();</span><br><span class="line">                _pCredential = NULL;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            hr = E_OUTOFMEMORY;</span><br><span class="line">        &#125;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    case CPUS_CHANGE_PASSWORD:</span><br><span class="line">    case CPUS_CREDUI:</span><br><span class="line">        hr = E_NOTIMPL;</span><br><span class="line">        break;</span><br><span class="line"></span><br><span class="line">    default:</span><br><span class="line">        hr = E_INVALIDARG;</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例中在登录和锁屏的两种情况都创建创建了 <code>CSampleCredential</code> 对象，这个对象就是实现凭据页面具体功能的对象。如果你需要区分登录和锁屏，那么在这里做区分创建不同的凭据对象，或者在凭据对象中判断 _cpus 的值（这个值被用作第一个参数传递到凭据对象中了）来显示不同的控件。</p>
<h2 id="CSampleCredential-Initialize"><a href="#CSampleCredential-Initialize" class="headerlink" title="CSampleCredential::Initialize"></a>CSampleCredential::Initialize</h2><p>注意，这里我们切换到了 CSampleCredential 类中，因为在上面介绍的方法中创建了一个 CSampleCredential 对象，并调用了该对象的 Initialize 方法，这个方法就实现了初始化凭据页面控件文字和数据的功能。同时，在调用这个方法时传递了三个参数，第一个参数就是我们刚才说的 _cpus，第二个参数描述了要创建的控件类型及控件初始化文字，第三个参数描述了创建的这些控件的初始状态，是显示、隐藏、还是具备焦点等。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Initializes one credential with the field information passed in.</span><br><span class="line">// Set the value of the SFI_LARGE_TEXT field to pwzUsername.</span><br><span class="line">HRESULT CSampleCredential::Initialize(</span><br><span class="line">    __in CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,</span><br><span class="line">    __in const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR* rgcpfd,    // 类型，控件的类型及默认显示文字</span><br><span class="line">    __in const FIELD_STATE_PAIR* rgfsp              // 状态，是否显示、是否是焦点等</span><br><span class="line">    )</span><br></pre></td></tr></table></figure>

<p>在 CSampleCredential::Initialize 函数中，遍历了这两个参数，并将这两个参数传递的内容保存到了自己类中的成员变量 _rgCredProvFieldDescriptors 和 _rgFieldStatePairs 中，这两个变量在初始化时与 CSampleProvider 初始化使用的都是相同的枚举。所以长度、成员类型、数量都是一样的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// Initializes one credential with the field information passed in.</span><br><span class="line">// Set the value of the SFI_LARGE_TEXT field to pwzUsername.</span><br><span class="line">HRESULT CSampleCredential::Initialize(</span><br><span class="line">    __in CREDENTIAL_PROVIDER_USAGE_SCENARIO cpus,</span><br><span class="line">    __in const CREDENTIAL_PROVIDER_FIELD_DESCRIPTOR* rgcpfd,    // 类型，控件的类型及默认显示文字</span><br><span class="line">    __in const FIELD_STATE_PAIR* rgfsp                          // 状态，是否显示、是否是焦点等</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line"></span><br><span class="line">    _cpus = cpus;</span><br><span class="line"></span><br><span class="line">    // Copy the field descriptors for each field. This is useful if you want to vary the field</span><br><span class="line">    // descriptors based on what Usage scenario the credential was created for.</span><br><span class="line">    for (DWORD i = 0; SUCCEEDED(hr) &amp;&amp; i &lt; ARRAYSIZE(_rgCredProvFieldDescriptors); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        _rgFieldStatePairs[i] = rgfsp[i];</span><br><span class="line">        hr = FieldDescriptorCopy(rgcpfd[i], &amp;_rgCredProvFieldDescriptors[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Initialize the String value of all the fields. </span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Large Text&quot;, &amp;_rgFieldStrings[SFI_LARGE_TEXT]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Small Text&quot;, &amp;_rgFieldStrings[SFI_SMALL_TEXT]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Edit Text&quot;, &amp;_rgFieldStrings[SFI_EDIT_TEXT]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;&quot;, &amp;_rgFieldStrings[SFI_PASSWORD]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Submit&quot;, &amp;_rgFieldStrings[SFI_SUBMIT_BUTTON]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Checkbox&quot;, &amp;_rgFieldStrings[SFI_CHECKBOX]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Combobox&quot;, &amp;_rgFieldStrings[SFI_COMBOBOX]);</span><br><span class="line">    &#125;</span><br><span class="line">    if (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        hr = SHStrDupW(L&quot;Command Link&quot;, &amp;_rgFieldStrings[SFI_COMMAND_LINK]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中我们可以看到，还有一个 _rgFieldStrings 的成员，是一个字符串指针数组变量，它是为了存储每个控件的文字信息，与 _rgCredProvFieldDescriptors 变量配合使用。给每隔字符串指针数组成员赋值后，初始化结束了。</p>
<h2 id="CSampleCredential-SetSelected"><a href="#CSampleCredential-SetSelected" class="headerlink" title="CSampleCredential::SetSelected"></a>CSampleCredential::SetSelected</h2><p>在初始化完成后，我们后续会看到一系列对控件初始化的一些操作，这些函数我们不必过度的去关心他，自己下个断点跟踪一下，就知道具体的执行过程了。接下来我们要介绍的这个函数就是在控件都初始化完毕后，你可能要在控件显示之前根据业务的不同情况对控件做一些改变，比如我们希望如果当前是锁屏而调用的凭据，那么我们只显示一个密码输入框，不需要显示用户名输入框了，因为锁屏的时候你可以通过代码判断出当前会话锁屏的用户信息。而如果是登录或切换用户而调用的凭据，那么我们要显示用户名和密码的输入框。当然这只是一个简单的业务场景描述，大家根据自己业务需求的不同即可在这个函数对控件的显示和隐藏做手脚。在这个函数操作控件前，你要先判断 _pCredProvCredentialEvents 成员是否是有效的，接着调用 _pCredProvCredentialEvents 的一些方法来对控件设置状态或文字等信息。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// LogonUI calls this function when our tile is selected (zoomed)</span><br><span class="line">// If you simply want fields to show/hide based on the selected state,</span><br><span class="line">// there&#x27;s no need to do anything here - you can set that up in the </span><br><span class="line">// field definitions. But if you want to do something</span><br><span class="line">// more complicated, like change the contents of a field when the tile is</span><br><span class="line">// selected, you would do it here.</span><br><span class="line">HRESULT CSampleCredential::SetSelected(__out BOOL* pbAutoLogon)  </span><br><span class="line">&#123;</span><br><span class="line">    if (NULL != _pCredProvCredentialEvents)</span><br><span class="line">    &#123;</span><br><span class="line">        // 设置 Combobox 控件为显示状态</span><br><span class="line">        _pCredProvCredentialEvents-&gt;SetFieldState(this, SFI_COMBOBOX, CPFS_DISPLAY_IN_SELECTED_TILE);</span><br><span class="line"></span><br><span class="line">        // 修改 SFI_LARGE_TEXT 控件的文字</span><br><span class="line">        _pCredProvCredentialEvents-&gt;SetFieldString(this, SFI_LARGE_TEXT, L&quot;Modify Large Text&quot;);</span><br><span class="line"></span><br><span class="line">        // 设置密码输入控件具备焦点</span><br><span class="line">        _pCredProvCredentialEvents-&gt;SetFieldInteractiveState(this, SFI_PASSWORD, CPFIS_FOCUSED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *pbAutoLogon = FALSE;  </span><br><span class="line">    return S_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码仅作示例，可能并没有什么实际作用。大家可能也注意到了 pbAutoLogon 参数，这个参数是一个传出参数，当你将它的值设置为 TRUE 的时候，系统将会尝试自动登录。这也是一个非常重要的特性，这里自动登录后，将直接触发我们下面要介绍的函数 GetSerialization。</p>
<h2 id="CSampleCredential-GetSerialization"><a href="#CSampleCredential-GetSerialization" class="headerlink" title="CSampleCredential::GetSerialization"></a>CSampleCredential::GetSerialization</h2><p>该函数就是界面上点击登录按钮，或者上面我们提到自动登录后触发的函数，再这里，你需要将界面上输入的用户名及密码等信息传递给系统，让操作系统去执行登录的操作。如下代码所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">// Collect the username and password into a serialized credential for the correct usage scenario </span><br><span class="line">// (logon/unlock is what&#x27;s demonstrated in this sample).  LogonUI then passes these credentials </span><br><span class="line">// back to the system to log on.</span><br><span class="line">HRESULT CSampleCredential::GetSerialization(</span><br><span class="line">    __out CREDENTIAL_PROVIDER_GET_SERIALIZATION_RESPONSE* pcpgsr,</span><br><span class="line">    __out CREDENTIAL_PROVIDER_CREDENTIAL_SERIALIZATION* pcpcs, </span><br><span class="line">    __deref_out_opt PWSTR* ppwszOptionalStatusText, </span><br><span class="line">    __in CREDENTIAL_PROVIDER_STATUS_ICON* pcpsiOptionalStatusIcon</span><br><span class="line">    )</span><br><span class="line">&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(ppwszOptionalStatusText);</span><br><span class="line">    UNREFERENCED_PARAMETER(pcpsiOptionalStatusIcon);</span><br><span class="line"></span><br><span class="line">    HRESULT hr;</span><br><span class="line"></span><br><span class="line">    WCHAR wsz[MAX_COMPUTERNAME_LENGTH+1];</span><br><span class="line">    DWORD cch = ARRAYSIZE(wsz);</span><br><span class="line">    if (GetComputerNameW(wsz, &amp;cch))</span><br><span class="line">    &#123;</span><br><span class="line">        PWSTR pwzProtectedPassword;</span><br><span class="line"></span><br><span class="line">        hr = ProtectIfNecessaryAndCopyPassword(_rgFieldStrings[SFI_PASSWORD], _cpus, &amp;pwzProtectedPassword);</span><br><span class="line"></span><br><span class="line">        if (SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            KERB_INTERACTIVE_UNLOCK_LOGON kiul;</span><br><span class="line"></span><br><span class="line">            hr = KerbInteractiveUnlockLogonInit(wsz, _rgFieldStrings[SFI_EDIT_TEXT], pwzProtectedPassword, _cpus, &amp;kiul);</span><br><span class="line"></span><br><span class="line">            if (SUCCEEDED(hr))</span><br><span class="line">            &#123;</span><br><span class="line">                // We use KERB_INTERACTIVE_UNLOCK_LOGON in both unlock and logon scenarios.  It contains a</span><br><span class="line">                // KERB_INTERACTIVE_LOGON to hold the creds plus a LUID that is filled in for us by Winlogon</span><br><span class="line">                // as necessary.</span><br><span class="line">                hr = KerbInteractiveUnlockLogonPack(kiul, &amp;pcpcs-&gt;rgbSerialization, &amp;pcpcs-&gt;cbSerialization);</span><br><span class="line"></span><br><span class="line">                if (SUCCEEDED(hr))</span><br><span class="line">                &#123;</span><br><span class="line">                    ULONG ulAuthPackage;</span><br><span class="line">                    hr = RetrieveNegotiateAuthPackage(&amp;ulAuthPackage);</span><br><span class="line">                    if (SUCCEEDED(hr))</span><br><span class="line">                    &#123;</span><br><span class="line">                        pcpcs-&gt;ulAuthenticationPackage = ulAuthPackage;</span><br><span class="line">                        pcpcs-&gt;clsidCredentialProvider = CLSID_CSample;</span><br><span class="line"></span><br><span class="line">                        // At this point the credential has created the serialized credential used for logon</span><br><span class="line">                        // By setting this to CPGSR_RETURN_CREDENTIAL_FINISHED we are letting logonUI know</span><br><span class="line">                        // that we have all the information we need and it should attempt to submit the </span><br><span class="line">                        // serialized credential.</span><br><span class="line">                        *pcpgsr = CPGSR_RETURN_CREDENTIAL_FINISHED;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            CoTaskMemFree(pwzProtectedPassword);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD dwErr = GetLastError();</span><br><span class="line">        hr = HRESULT_FROM_WIN32(dwErr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数中调用了获取计算机名的 API，并调用几个功能函数填充了登录系统所需的结构体，传递给系统进行登录。填充结构体的几个功能函数大家可以自己看一看，并不复杂。</p>
<h2 id="CSampleCredential-ReportResult"><a href="#CSampleCredential-ReportResult" class="headerlink" title="CSampleCredential::ReportResult"></a>CSampleCredential::ReportResult</h2><p>ReportResult 函数是我们点击确定按钮登录系统后，操作登录反馈给我们结果的函数。你的登录成功了、密码过期了、密码错误了等信息都可以通过这个函数捕获到，配合上面的 GetSerialization 函数你可以完成一系列非常严谨的身份认证功能。ReportResult 函数有 4 个参数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HRESULT CSampleCredential::ReportResult(</span><br><span class="line">    __in NTSTATUS ntsStatus,                                            // 错误代码</span><br><span class="line">    __in NTSTATUS ntsSubstatus,                                         // 附加错误代码</span><br><span class="line">    __deref_out_opt PWSTR* ppwszOptionalStatusText,                     // 错误提示文字，系统会给我们写好，我们也可以自己修改</span><br><span class="line">    __out CREDENTIAL_PROVIDER_STATUS_ICON* pcpsiOptionalStatusIcon      // 界面上显示的错误图标</span><br><span class="line">    );</span><br></pre></td></tr></table></figure>

<p>当你在使用的时候，建议你在该函数的入口处增加一处日志，打印出 ntsStatus 和 ntsSubStatus 的值。这样在遇到一些没遇到过的错误时，可以通过日志来分析问题。示例代码中给我们提供了两种错误示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">static const REPORT_RESULT_STATUS_INFO s_rgLogonStatusInfo[] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; STATUS_LOGON_FAILURE, STATUS_SUCCESS, L&quot;Incorrect password or username.&quot;, CPSI_ERROR, &#125;,</span><br><span class="line">    &#123; STATUS_ACCOUNT_RESTRICTION, STATUS_ACCOUNT_DISABLED, L&quot;The account is disabled.&quot;, CPSI_WARNING &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>一种是登录失败的错误码，一种是用户被禁用的错误码。如果想知道更多的错误码，比如密码过期等，可以从这两个宏跟进去就能看到所有的错误码了。最终你可以根据这些错误码给出不同的提示，当然提示的字符串 ppwszOptionalStatusText 也是可以修改的，你只需要调用 SHStrDupW 函数向这个字符串填充一些你想提示的字符串即可。调用前别忘记释放这个字符串的内存哦。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-23</span><i class="fa fa-tag"></i><a class="tag" href="/categories/platform/" title="platform">platform </a><a class="tag" href="/categories/language/" title="language">language </a><a class="tag" href="/categories/language/C-C/" title="C/C++">C/C++ </a><a class="tag" href="/categories/Platform/" title="Platform">Platform </a><a class="tag" href="/categories/Language/" title="Language">Language </a><a class="tag" href="/categories/platform/Windows/" title="Windows">Windows </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,https://nmgwddj.github.io/2016/12/23/2016/2016-12-23_113743-1961/,Dylan's blog,微软 Credential Providers 详解二《关键函数》,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/01/01/2017/2017-01-01_231237-1968/" title="创建离线的 Visual Studio 2017 RC ISO 安装包">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2016/12/18/2016/2016-12-18_191620-1945/" title="微软 Credential Providers 详解一《调用原理》">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>