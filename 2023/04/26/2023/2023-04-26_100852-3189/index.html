<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Qt6 QML 中渲染自定义视频帧的改进 2023-05-30 更新 | Dylan&#39;s blog</title>
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(https://avatars.githubusercontent.com/u/13995319?v=4)">
        </div>
    </section>
    <section class='menu'>
        <div>Dylan&#39;s blog</div>
        
            <div>To the pursuit of truth.</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>Qt6 QML 中渲染自定义视频帧的改进 2023-05-30 更新</h1>
    </header>

    <section>
      <p>最近在升级音视频的项目 Qt 版本，从 5.15.0 升级到 6.4.3（6.5 也一样），除了一些 QML 中删除了一些 Qt Quick Controls 1 的控件以外，最重要的就是自定义视频渲染的改进。</p>
<span id="more"></span>
<h2 id="QAbstractVideoSurface-变为-QVideoSink"><a href="#QAbstractVideoSurface-变为-QVideoSink" class="headerlink" title="QAbstractVideoSurface 变为 QVideoSink"></a>QAbstractVideoSurface 变为 QVideoSink</h2><p>Qt5 中在 QML 上渲染自定义视频帧时需要在 C++ 层实现一个派生于 QObject 的子类，内部使用 <code>QAbstractVideoSurface</code> 来给 VideoOutput 提供数据，具体方法这里就不讨论了，可以参考我之前写的文章 <a target="_blank" rel="noopener" href="https://www.mycode.net.cn/language/cpp/2719.html">Qt QML VideoOutput 显示自定义的 YUV420P 数据流</a> 在 Qt6 中，QAbstractVideoSurface 被 QVideoSink 替代，提供了更简单的方式来投递一个 QVideoFrame，示例代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FrameProvider</span> : <span class="keyword">public</span> QObject &#123;</span><br><span class="line">    <span class="function">Q_OBJECT</span></span><br><span class="line"><span class="function">    <span class="title">Q_PROPERTY</span><span class="params">(QVideoSink* videoSink READ videoSink WRITE setVideoSink NOTIFY videoSinkChanged)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">public</span>:</span></span><br><span class="line"><span class="function">    explicit FrameProvider(QObject* parent =</span> <span class="literal">nullptr</span>);</span><br><span class="line">    ~<span class="built_in">FrameProvider</span>();</span><br><span class="line"></span><br><span class="line">    <span class="function">QVideoSink* <span class="title">videoSink</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> m_videoSink; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setVideoSink</span><span class="params">(QVideoSink* videoSink)</span></span>;</span><br><span class="line"></span><br><span class="line">signals:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">videoSinkChanged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> slots:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deliverFrame</span><span class="params">(<span class="type">const</span> QVideoFrame&amp; frame)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    QPointer&lt;QVideoSink&gt; m_videoSink;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>类声明一个槽函数 <code>deliverFrame</code> 提供视频帧提供的模块绑定并投递帧数据。在 cpp 实现中只如果有新的视频流，则直接调用 m_videoSink 的 setVideoFrame 方法就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">FrameProvider::deliverFrame</span><span class="params">(<span class="type">const</span> QVideoFrame&amp; frame)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!m_videoSink)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    m_videoSink-&gt;<span class="built_in">setVideoFrame</span>(frame);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将 FrameProvider 按上面文章中的方法一样，注册给到 QML 端，与 VideoOutput 配合使用时也稍微有一些变动：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FrameProvider &#123;</span><br><span class="line">    id: frameProvider</span><br><span class="line">    videoSink: videoContainer.videoSink</span><br><span class="line">&#125;</span><br><span class="line">VideoOutput &#123;</span><br><span class="line">    id: videoContainer</span><br><span class="line">    anchors.fill: parent</span><br><span class="line">    fillMode: VideoOutput.PreserveAspectFit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样 VideoOutput 与新的 FrameProvider 配合使用就完成了，接下来我们说一下 QVideoFrame 的变动：</p>
<h2 id="QVideoFrame-数据拷贝方式的变动"><a href="#QVideoFrame-数据拷贝方式的变动" class="headerlink" title="QVideoFrame 数据拷贝方式的变动"></a>QVideoFrame 数据拷贝方式的变动</h2><p>在 Qt5 中，如拷贝 YUV 数据到 QVideoFrame 的方式非常暴力，通过 videoFrame.bits() 拿到地址算好位置无脑拷贝就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> frameSize = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.width * frame.height * frame.count / <span class="number">2</span>);</span><br><span class="line"><span class="function">QVideoFrame <span class="title">videoFrame</span><span class="params">(frameSize, QSize(<span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationWidth), <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationHeight)), <span class="keyword">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationWidth),</span></span></span><br><span class="line"><span class="params"><span class="function">                       QVideoFrame::Format_YUV420P)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (videoFrame.<span class="built_in">map</span>(QAbstractVideoBuffer::WriteOnly)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> src = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(frame.data);</span><br><span class="line">    <span class="keyword">auto</span> dest = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(videoFrame.<span class="built_in">bits</span>());</span><br><span class="line"></span><br><span class="line">    libyuv::<span class="built_in">I420Rotate</span>(src + frame.offset[<span class="number">0</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.stride[<span class="number">0</span>]),</span><br><span class="line">                       src + frame.offset[<span class="number">1</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.stride[<span class="number">1</span>]),</span><br><span class="line">                       src + frame.offset[<span class="number">2</span>], <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.stride[<span class="number">2</span>]),</span><br><span class="line">                       dest, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationWidth),</span><br><span class="line">                       dest + rotationWidth * rotationHeight, rotationWidth / <span class="number">2</span>,</span><br><span class="line">                       dest + rotationWidth * rotationHeight + rotationWidth * rotationHeight / <span class="number">4</span>, rotationWidth / <span class="number">2</span>,</span><br><span class="line">                       <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.width), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(frame.height), rotate_mode);</span><br><span class="line"></span><br><span class="line">    videoFrame.<span class="built_in">setStartTime</span>(<span class="number">0</span>);</span><br><span class="line">    videoFrame.<span class="built_in">unmap</span>();</span><br><span class="line"></span><br><span class="line">    QSize size = <span class="built_in">QSize</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationWidth), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationHeight));</span><br><span class="line">    emit VideoManager::m_videoFrameDelegate-&gt;<span class="built_in">receivedVideoFrame</span>(QString::<span class="built_in">fromStdString</span>(accountId), videoFrame, size, bSub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但 Qt6 中出现了较大的变动，首先 bits 函数要求传递目标数据的 plane，比如 Y plane 为 0，U 和 V 依次为 1 和 2。这看起来跟 Qt5 中没有什么太大区别，但如果你按 bits(0)、bits(1)、bits(1) 的地址按原来的逻辑拷贝时会发现部分分辨率的图像会渲染错乱，这基本上是因为原始的 YUV 数据宽度并不是 16 的倍数。而 QVideoFrame 一旦调用了 map 函数，则每个 plane 的 stride（在 Qt 中称为 bytesPerLine） 将会是 16 的倍数，如果你按原始数据宽度拷贝，就会导致画面错乱。 正确的做法是通过 QVideoFrame 提供的 bytesPerLine() 方法算出具体每个 plane 的宽度，按需拷贝，实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">QVideoFrameFormat <span class="title">format</span><span class="params">(QSize(rotationWidth, rotationHeight), QVideoFrameFormat::Format_YUV420P)</span></span>;</span><br><span class="line">format.<span class="built_in">setViewport</span>(<span class="built_in">QRect</span>(<span class="number">0</span>, <span class="number">0</span>, rotationWidth, rotationHeight));</span><br><span class="line"><span class="function">QVideoFrame <span class="title">videoFrame</span><span class="params">(format)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (videoFrame.<span class="built_in">map</span>(QVideoFrame::WriteOnly)) &#123;</span><br><span class="line">    <span class="keyword">auto</span> src = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uint8_t</span>*&gt;(frame.data);</span><br><span class="line">    <span class="comment">// If the aspect ratio of the original data is not a multiple of 16,</span></span><br><span class="line">    <span class="comment">// when mappedBytes(n) is called after frame mapping, the returned size will be expanded to the nearest multiple of 16.</span></span><br><span class="line">    <span class="comment">// When copying the data, bytesPerLine(n) should be used to get the actual stride that needs to be copied.</span></span><br><span class="line">    libyuv::<span class="built_in">I420Rotate</span>(src + frame.offset[<span class="number">0</span>], frame.stride[<span class="number">0</span>],</span><br><span class="line">                       src + frame.offset[<span class="number">1</span>], frame.stride[<span class="number">1</span>],</span><br><span class="line">                       src + frame.offset[<span class="number">2</span>], frame.stride[<span class="number">2</span>],</span><br><span class="line">                       videoFrame.<span class="built_in">bits</span>(<span class="number">0</span>), videoFrame.<span class="built_in">bytesPerLine</span>(<span class="number">0</span>),</span><br><span class="line">                       videoFrame.<span class="built_in">bits</span>(<span class="number">1</span>), videoFrame.<span class="built_in">bytesPerLine</span>(<span class="number">1</span>),</span><br><span class="line">                       videoFrame.<span class="built_in">bits</span>(<span class="number">2</span>), videoFrame.<span class="built_in">bytesPerLine</span>(<span class="number">2</span>),</span><br><span class="line">                       frame.width, frame.height, rotate_mode);</span><br><span class="line">    videoFrame.<span class="built_in">setStartTime</span>(<span class="number">0</span>);</span><br><span class="line">    videoFrame.<span class="built_in">unmap</span>();</span><br><span class="line">    QSize size = <span class="built_in">QSize</span>(<span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationWidth), <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(rotationHeight));</span><br><span class="line">    emit VideoManager::m_videoFrameDelegate-&gt;<span class="built_in">receivedVideoFrame</span>(QString::<span class="built_in">fromStdString</span>(accountId), videoFrame, size, bSub);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 frame.data 是 YUV 的原始数据。通过改动后的 QVideoFrame API 我们可以看到，Qt 对视频处理数据的要求更加严谨了，虽然处理问题过程中浪费了比较多的时间，但总算总结下了一些宝贵的经验。</p>
<h2 id="2023-05-30-更新"><a href="#2023-05-30-更新" class="headerlink" title="2023-05-30 更新"></a>2023-05-30 更新</h2><p>以上拷贝方式当使用 Qt 6.x 版本默认的渲染引擎（OpenGL）时一些奇葩的分辨率会出现花屏的问题。修改 Qt 的渲染引擎为各平台特有引擎后得以解决：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="function">QGuiApplication <span class="title">app</span><span class="params">(argc, argv)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(Q_OS_MACX)</span></span><br><span class="line">    QQuickWindow::<span class="built_in">setGraphicsApi</span>(QSGRendererInterface::Metal);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    QQuickWindow::<span class="built_in">setGraphicsApi</span>(QSGRendererInterface::Direct3D11);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ..... other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2023-04-26T10:08:52.000Z" itemprop="datePublished">
              2023-04-26
            </time>
          </div>
          
            <div>
              tags: 
  <li class="meta-text">
  { <a href="/tags/Qt/">Qt</a> }
  </li>

  <li class="meta-text">
  { <a href="/tags/Qt-Quick/">Qt Quick</a> }
  </li>


            </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2023 - Dylan </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>